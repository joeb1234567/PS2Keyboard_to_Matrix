   1               		.file	"ps2kbd.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	ps2_kbd_init
  12               	ps2_kbd_init:
  13               	.LFB8:
  14               		.file 1 "common/ps2kbd.c"
   1:common/ps2kbd.c **** /* PS/2 keyboard routines by Jurre Hanema, version 1.0
   2:common/ps2kbd.c ****  * ps2kbd.c
   3:common/ps2kbd.c ****  *
   4:common/ps2kbd.c ****  * Released under "THE BEER-WARE LICENSE" (Revision 42):
   5:common/ps2kbd.c ****  * <kipmans@gmail.com> wrote this file. As long as you retain this notice you can 
   6:common/ps2kbd.c ****  * do whatever you want with this stuff. If we meet some day, and you think this 
   7:common/ps2kbd.c ****  * stuff is worth it, you can buy me a beer in return.
   8:common/ps2kbd.c ****  */
   9:common/ps2kbd.c **** 
  10:common/ps2kbd.c **** /*
  11:common/ps2kbd.c ****     Modified March-October 2009, P.Harvey-Smith to more suit the needs of the 
  12:common/ps2kbd.c ****     Atom/BBC/Electron keyboard interfaces.
  13:common/ps2kbd.c **** 
  14:common/ps2kbd.c **** 	2010-07-03, P.Harvey-Smith.
  15:common/ps2kbd.c **** 	Changed keyboard queue handling to use a propper ring buffer rather than a stack!
  16:common/ps2kbd.c **** 	
  17:common/ps2kbd.c **** 	2010-07-04, P.Harvey-Smith.
  18:common/ps2kbd.c **** 	Changed nested if statements to be a switch as I think this makes the code clearer
  19:common/ps2kbd.c **** 	if a little more verbose !
  20:common/ps2kbd.c **** 	Receive code now checks parity bit and only queues scancode if parity is valid.
  21:common/ps2kbd.c **** 	
  22:common/ps2kbd.c **** 	2011-04-27, Changed all externally callable routines to have the prefix
  23:common/ps2kbd.c **** 	ps2_kbd_
  24:common/ps2kbd.c **** 
  25:common/ps2kbd.c **** */
  26:common/ps2kbd.c **** 
  27:common/ps2kbd.c **** #include <avr/io.h>
  28:common/ps2kbd.c **** #include <avr/interrupt.h>
  29:common/ps2kbd.c **** #include <avr/pgmspace.h>
  30:common/ps2kbd.c **** #include <util/delay.h>
  31:common/ps2kbd.c **** 
  32:common/ps2kbd.c **** #include "ps2kbd.h"
  33:common/ps2kbd.c **** #include "status.h"
  34:common/ps2kbd.c **** 
  35:common/ps2kbd.c **** #define LOGIC_XOR(a, b)	(((a) && !(b)) || ((b) && !(a)))
  36:common/ps2kbd.c **** 
  37:common/ps2kbd.c **** volatile uint8_t	kbd_bit_n = 1;
  38:common/ps2kbd.c **** volatile uint8_t	kbd_n_bits = 0;
  39:common/ps2kbd.c **** volatile uint8_t	kbd_buffer = 0;
  40:common/ps2kbd.c **** volatile uint8_t	kbd_queue[KBD_BUFSIZE + 1];
  41:common/ps2kbd.c **** volatile uint8_t	kbd_queue_idx = 0;
  42:common/ps2kbd.c **** volatile uint8_t	kbd_parity;
  43:common/ps2kbd.c **** 
  44:common/ps2kbd.c **** volatile uint8_t	kbd_queue_insert = 0;
  45:common/ps2kbd.c **** volatile uint8_t	kbd_queue_remove = 0;
  46:common/ps2kbd.c **** volatile uint16_t	kbd_status = 0;
  47:common/ps2kbd.c **** 
  48:common/ps2kbd.c **** uint8_t	PS2_LEDS;
  49:common/ps2kbd.c **** uint8_t	PS2_LEDS_OLD;
  50:common/ps2kbd.c **** 
  51:common/ps2kbd.c **** #define KQueueHasSpace()	(((kbd_queue_insert % KBD_BUFSIZE)+1) != (kbd_queue_remove % KBD_BUFSIZE))
  52:common/ps2kbd.c **** #define KQueueEmpty()		((kbd_queue_insert % KBD_BUFSIZE) == (kbd_queue_remove % KBD_BUFSIZE))
  53:common/ps2kbd.c **** 
  54:common/ps2kbd.c **** // Begin actual implementation
  55:common/ps2kbd.c **** 
  56:common/ps2kbd.c **** void ps2_kbd_init()
  57:common/ps2kbd.c **** {
  15               		.loc 1 57 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  58:common/ps2kbd.c **** 	kbd_queue[KBD_BUFSIZE] = 0;
  21               		.loc 1 58 0
  22 0000 1092 0000 		sts kbd_queue+128,__zero_reg__
  59:common/ps2kbd.c **** 	kbd_queue_insert = 0;
  23               		.loc 1 59 0
  24 0004 1092 0000 		sts kbd_queue_insert,__zero_reg__
  60:common/ps2kbd.c **** 	kbd_queue_remove = 0;
  25               		.loc 1 60 0
  26 0008 1092 0000 		sts kbd_queue_remove,__zero_reg__
  61:common/ps2kbd.c **** 	kbd_status = 0;
  27               		.loc 1 61 0
  28 000c 1092 0000 		sts kbd_status+1,__zero_reg__
  29 0010 1092 0000 		sts kbd_status,__zero_reg__
  62:common/ps2kbd.c **** 	kbd_parity = 0;
  30               		.loc 1 62 0
  31 0014 1092 0000 		sts kbd_parity,__zero_reg__
  63:common/ps2kbd.c **** 	
  64:common/ps2kbd.c **** 	PS2_LEDS = 0;
  32               		.loc 1 64 0
  33 0018 1092 0000 		sts PS2_LEDS,__zero_reg__
  65:common/ps2kbd.c **** 	PS2_LEDS_OLD = PS2_LEDS;
  34               		.loc 1 65 0
  35 001c 1092 0000 		sts PS2_LEDS_OLD,__zero_reg__
  66:common/ps2kbd.c **** 	
  67:common/ps2kbd.c **** 	// Set interrupts
  68:common/ps2kbd.c **** 	
  69:common/ps2kbd.c **** 	KBD_SET_INT();
  36               		.loc 1 69 0
  37 0020 E9E6      		ldi r30,lo8(105)
  38 0022 F0E0      		ldi r31,0
  39 0024 8081      		ld r24,Z
  40 0026 8C7F      		andi r24,lo8(-4)
  41 0028 8083      		st Z,r24
  42 002a 8081      		ld r24,Z
  43 002c 8260      		ori r24,lo8(2)
  44 002e 8083      		st Z,r24
  70:common/ps2kbd.c **** 	KBD_EN_INT();
  45               		.loc 1 70 0
  46 0030 E89A      		sbi 0x1d,0
  71:common/ps2kbd.c **** 	
  72:common/ps2kbd.c **** 	// Enable pullup on clock
  73:common/ps2kbd.c **** 	
  74:common/ps2kbd.c **** 	KBD_CLOCK_PORT |= KBD_CLOCK_MASK;
  47               		.loc 1 74 0
  48 0032 5A9A      		sbi 0xb,2
  49 0034 0895      		ret
  50               		.cfi_endproc
  51               	.LFE8:
  53               	.global	ps2_kbd_queue_scancode
  55               	ps2_kbd_queue_scancode:
  56               	.LFB9:
  75:common/ps2kbd.c **** }
  76:common/ps2kbd.c **** 
  77:common/ps2kbd.c **** 
  78:common/ps2kbd.c **** uint8_t ps2_kbd_queue_scancode(volatile uint8_t p)
  79:common/ps2kbd.c **** {
  57               		.loc 1 79 0
  58               		.cfi_startproc
  59               	.LVL0:
  60 0036 CF93      		push r28
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 28, -2
  64 0038 DF93      		push r29
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 29, -3
  68 003a 1F92      		push __zero_reg__
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71 003c CDB7      		in r28,__SP_L__
  72 003e DEB7      		in r29,__SP_H__
  73               	.LCFI3:
  74               		.cfi_def_cfa_register 28
  75               	/* prologue: function */
  76               	/* frame size = 1 */
  77               	/* stack size = 3 */
  78               	.L__stack_usage = 3
  79 0040 8983      		std Y+1,r24
  80:common/ps2kbd.c **** 	if(KQueueHasSpace())
  80               		.loc 1 80 0
  81 0042 8091 0000 		lds r24,kbd_queue_insert
  82               	.LVL1:
  83 0046 2091 0000 		lds r18,kbd_queue_remove
  84 004a 8F77      		andi r24,lo8(127)
  85 004c 90E0      		ldi r25,0
  86 004e 0196      		adiw r24,1
  87 0050 2F77      		andi r18,lo8(127)
  88 0052 30E0      		ldi r19,0
  89 0054 8217      		cp r24,r18
  90 0056 9307      		cpc r25,r19
  91 0058 01F0      		breq .L4
  81:common/ps2kbd.c **** 	{
  82:common/ps2kbd.c **** 		kbd_queue[kbd_queue_insert++] = p;
  92               		.loc 1 82 0
  93 005a E091 0000 		lds r30,kbd_queue_insert
  94 005e 81E0      		ldi r24,lo8(1)
  95 0060 8E0F      		add r24,r30
  96 0062 8093 0000 		sts kbd_queue_insert,r24
  97               	.LVL2:
  98 0066 F0E0      		ldi r31,0
  99 0068 8981      		ldd r24,Y+1
 100 006a E050      		subi r30,lo8(-(kbd_queue))
 101 006c F040      		sbci r31,hi8(-(kbd_queue))
 102 006e 8083      		st Z,r24
  83:common/ps2kbd.c **** 		kbd_queue_insert %= KBD_BUFSIZE;
 103               		.loc 1 83 0
 104 0070 8091 0000 		lds r24,kbd_queue_insert
 105 0074 8F77      		andi r24,lo8(127)
 106 0076 8093 0000 		sts kbd_queue_insert,r24
  84:common/ps2kbd.c **** 	} else
  85:common/ps2kbd.c **** 		return 0;
  86:common/ps2kbd.c **** 
  87:common/ps2kbd.c **** 	return 1;
 107               		.loc 1 87 0
 108 007a 81E0      		ldi r24,lo8(1)
 109 007c 00C0      		rjmp .L3
 110               	.LVL3:
 111               	.L4:
  85:common/ps2kbd.c **** 
 112               		.loc 1 85 0
 113 007e 80E0      		ldi r24,0
 114               	.LVL4:
 115               	.L3:
 116               	/* epilogue start */
  88:common/ps2kbd.c **** }
 117               		.loc 1 88 0
 118 0080 0F90      		pop __tmp_reg__
 119 0082 DF91      		pop r29
 120 0084 CF91      		pop r28
 121 0086 0895      		ret
 122               		.cfi_endproc
 123               	.LFE9:
 125               	.global	ps2_kbd_get_scancode
 127               	ps2_kbd_get_scancode:
 128               	.LFB10:
  89:common/ps2kbd.c **** 
  90:common/ps2kbd.c **** 
  91:common/ps2kbd.c **** uint8_t ps2_kbd_get_scancode(void)
  92:common/ps2kbd.c **** {
 129               		.loc 1 92 0
 130               		.cfi_startproc
 131               	/* prologue: function */
 132               	/* frame size = 0 */
 133               	/* stack size = 0 */
 134               	.L__stack_usage = 0
  93:common/ps2kbd.c **** 	uint8_t		result;
  94:common/ps2kbd.c **** 
  95:common/ps2kbd.c **** 	if(!KQueueEmpty())
 135               		.loc 1 95 0
 136 0088 9091 0000 		lds r25,kbd_queue_insert
 137 008c 8091 0000 		lds r24,kbd_queue_remove
 138 0090 8927      		eor r24,r25
 139 0092 8F77      		andi r24,lo8(127)
 140 0094 01F0      		breq .L7
  96:common/ps2kbd.c **** 	{
  97:common/ps2kbd.c **** 		cli();
 141               		.loc 1 97 0
 142               	/* #APP */
 143               	 ;  97 "common/ps2kbd.c" 1
 144 0096 F894      		cli
 145               	 ;  0 "" 2
  98:common/ps2kbd.c **** 		result=kbd_queue[kbd_queue_remove++]; 
 146               		.loc 1 98 0
 147               	/* #NOAPP */
 148 0098 E091 0000 		lds r30,kbd_queue_remove
 149 009c 81E0      		ldi r24,lo8(1)
 150 009e 8E0F      		add r24,r30
 151 00a0 8093 0000 		sts kbd_queue_remove,r24
 152 00a4 F0E0      		ldi r31,0
 153 00a6 E050      		subi r30,lo8(-(kbd_queue))
 154 00a8 F040      		sbci r31,hi8(-(kbd_queue))
 155 00aa 8081      		ld r24,Z
 156               	.LVL5:
  99:common/ps2kbd.c **** 		kbd_queue_remove %= KBD_BUFSIZE;
 157               		.loc 1 99 0
 158 00ac 9091 0000 		lds r25,kbd_queue_remove
 159 00b0 9F77      		andi r25,lo8(127)
 160 00b2 9093 0000 		sts kbd_queue_remove,r25
 100:common/ps2kbd.c **** 		sei();
 161               		.loc 1 100 0
 162               	/* #APP */
 163               	 ;  100 "common/ps2kbd.c" 1
 164 00b6 7894      		sei
 165               	 ;  0 "" 2
 166               	.LVL6:
 167               	/* #NOAPP */
 168               	.L7:
 101:common/ps2kbd.c **** 		
 102:common/ps2kbd.c **** 		return result;
 103:common/ps2kbd.c **** 	} else
 104:common/ps2kbd.c **** 		return 0;
 105:common/ps2kbd.c **** }
 169               		.loc 1 105 0
 170 00b8 0895      		ret
 171               		.cfi_endproc
 172               	.LFE10:
 174               	.global	ps2_kbd_send
 176               	ps2_kbd_send:
 177               	.LFB11:
 106:common/ps2kbd.c **** 
 107:common/ps2kbd.c **** 
 108:common/ps2kbd.c **** void ps2_kbd_send(uint8_t data)
 109:common/ps2kbd.c **** {
 178               		.loc 1 109 0
 179               		.cfi_startproc
 180               	.LVL7:
 181               	/* prologue: function */
 182               	/* frame size = 0 */
 183               	/* stack size = 0 */
 184               	.L__stack_usage = 0
 185               	.L12:
 110:common/ps2kbd.c **** 	//logv0("kbd_send(%2X), kbd_status=%4X, kbd_bit_n=%d\n",data,kbd_status,kbd_bit_n);
 111:common/ps2kbd.c **** 	
 112:common/ps2kbd.c **** 	// This behaviour isn't the most desirable, but it's the easiest and proved to be reliable.
 113:common/ps2kbd.c **** 	while(kbd_status & (KBD_SEND | KBD_RECEIVE)) 
 186               		.loc 1 113 0
 187 00ba 2091 0000 		lds r18,kbd_status
 188 00be 3091 0000 		lds r19,kbd_status+1
 189 00c2 2078      		andi r18,128
 190 00c4 3170      		andi r19,1
 191 00c6 232B      		or r18,r19
 192 00c8 01F0      		breq .L14
 114:common/ps2kbd.c **** 		asm("nop");	
 193               		.loc 1 114 0
 194               	/* #APP */
 195               	 ;  114 "common/ps2kbd.c" 1
 196 00ca 0000      		nop
 197               	 ;  0 "" 2
 198               	/* #NOAPP */
 199 00cc 00C0      		rjmp .L12
 200               	.L14:
 115:common/ps2kbd.c **** 	
 116:common/ps2kbd.c **** 	// Initiate request-to-send, the actual sending of the data
 117:common/ps2kbd.c **** 	// is handled in the ISR.
 118:common/ps2kbd.c **** 	
 119:common/ps2kbd.c **** 	KBD_CLOCK_PORT &= ~(1<<KBD_CLOCK_BIT);
 201               		.loc 1 119 0
 202 00ce 5A98      		cbi 0xb,2
 120:common/ps2kbd.c **** 	KBD_CLOCK_DDR  |= (1<<KBD_CLOCK_BIT);
 203               		.loc 1 120 0
 204 00d0 529A      		sbi 0xa,2
 205               	.LVL8:
 206               	.LBB4:
 207               	.LBB5:
 208               		.file 2 "d:\\winavr\\avr\\include\\util\\delay.h"
   1:d:\winavr\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:d:\winavr\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:d:\winavr\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:d:\winavr\avr\include\util\delay.h ****    All rights reserved.
   5:d:\winavr\avr\include\util\delay.h **** 
   6:d:\winavr\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:d:\winavr\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:d:\winavr\avr\include\util\delay.h **** 
   9:d:\winavr\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:d:\winavr\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:d:\winavr\avr\include\util\delay.h **** 
  12:d:\winavr\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:d:\winavr\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:d:\winavr\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:d:\winavr\avr\include\util\delay.h ****      distribution.
  16:d:\winavr\avr\include\util\delay.h **** 
  17:d:\winavr\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:d:\winavr\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:d:\winavr\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:d:\winavr\avr\include\util\delay.h **** 
  21:d:\winavr\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:d:\winavr\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:d:\winavr\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:d:\winavr\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:d:\winavr\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:d:\winavr\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:d:\winavr\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:d:\winavr\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:d:\winavr\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:d:\winavr\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:d:\winavr\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:d:\winavr\avr\include\util\delay.h **** 
  33:d:\winavr\avr\include\util\delay.h **** /* $Id$ */
  34:d:\winavr\avr\include\util\delay.h **** 
  35:d:\winavr\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:d:\winavr\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:d:\winavr\avr\include\util\delay.h **** 
  38:d:\winavr\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:d:\winavr\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:d:\winavr\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:d:\winavr\avr\include\util\delay.h **** #  endif
  42:d:\winavr\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:d:\winavr\avr\include\util\delay.h **** 
  44:d:\winavr\avr\include\util\delay.h **** #include <inttypes.h>
  45:d:\winavr\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:d:\winavr\avr\include\util\delay.h **** #include <math.h>
  47:d:\winavr\avr\include\util\delay.h **** 
  48:d:\winavr\avr\include\util\delay.h **** /** \file */
  49:d:\winavr\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:d:\winavr\avr\include\util\delay.h ****     \code
  51:d:\winavr\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:d:\winavr\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:d:\winavr\avr\include\util\delay.h ****     #include <util/delay.h>
  54:d:\winavr\avr\include\util\delay.h ****     \endcode
  55:d:\winavr\avr\include\util\delay.h **** 
  56:d:\winavr\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:d:\winavr\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:d:\winavr\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:d:\winavr\avr\include\util\delay.h ****     used.
  60:d:\winavr\avr\include\util\delay.h **** 
  61:d:\winavr\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:d:\winavr\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:d:\winavr\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:d:\winavr\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:d:\winavr\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:d:\winavr\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:d:\winavr\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:d:\winavr\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:d:\winavr\avr\include\util\delay.h **** 
  70:d:\winavr\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:d:\winavr\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:d:\winavr\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:d:\winavr\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:d:\winavr\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:d:\winavr\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:d:\winavr\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:d:\winavr\avr\include\util\delay.h ****     routines linked into the application.
  78:d:\winavr\avr\include\util\delay.h **** 
  79:d:\winavr\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:d:\winavr\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:d:\winavr\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:d:\winavr\avr\include\util\delay.h **** 
  83:d:\winavr\avr\include\util\delay.h **** */
  84:d:\winavr\avr\include\util\delay.h **** 
  85:d:\winavr\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:d:\winavr\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:d:\winavr\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:d:\winavr\avr\include\util\delay.h **** #endif
  89:d:\winavr\avr\include\util\delay.h **** 
  90:d:\winavr\avr\include\util\delay.h **** #ifndef F_CPU
  91:d:\winavr\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:d:\winavr\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:d:\winavr\avr\include\util\delay.h **** /** \ingroup util_delay
  94:d:\winavr\avr\include\util\delay.h ****     \def F_CPU
  95:d:\winavr\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:d:\winavr\avr\include\util\delay.h **** 
  97:d:\winavr\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:d:\winavr\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:d:\winavr\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:d:\winavr\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:d:\winavr\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:d:\winavr\avr\include\util\delay.h **** 
 103:d:\winavr\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:d:\winavr\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:d:\winavr\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:d:\winavr\avr\include\util\delay.h ****     integer value.
 107:d:\winavr\avr\include\util\delay.h ****  */
 108:d:\winavr\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:d:\winavr\avr\include\util\delay.h **** #endif
 110:d:\winavr\avr\include\util\delay.h **** 
 111:d:\winavr\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:d:\winavr\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:d:\winavr\avr\include\util\delay.h **** #endif
 114:d:\winavr\avr\include\util\delay.h **** 
 115:d:\winavr\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:d:\winavr\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:d:\winavr\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:d:\winavr\avr\include\util\delay.h **** #  include <math.h>
 119:d:\winavr\avr\include\util\delay.h **** #endif
 120:d:\winavr\avr\include\util\delay.h **** 
 121:d:\winavr\avr\include\util\delay.h **** /**
 122:d:\winavr\avr\include\util\delay.h ****    \ingroup util_delay
 123:d:\winavr\avr\include\util\delay.h **** 
 124:d:\winavr\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:d:\winavr\avr\include\util\delay.h **** 
 126:d:\winavr\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:d:\winavr\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:d:\winavr\avr\include\util\delay.h **** 
 129:d:\winavr\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:d:\winavr\avr\include\util\delay.h **** 
 131:d:\winavr\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:d:\winavr\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:d:\winavr\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:d:\winavr\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:d:\winavr\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:d:\winavr\avr\include\util\delay.h **** 
 137:d:\winavr\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:d:\winavr\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:d:\winavr\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:d:\winavr\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:d:\winavr\avr\include\util\delay.h **** 
 142:d:\winavr\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:d:\winavr\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:d:\winavr\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:d:\winavr\avr\include\util\delay.h ****    microseconds of delay.
 146:d:\winavr\avr\include\util\delay.h **** 
 147:d:\winavr\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:d:\winavr\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:d:\winavr\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:d:\winavr\avr\include\util\delay.h ****    respectively.
 151:d:\winavr\avr\include\util\delay.h **** 
 152:d:\winavr\avr\include\util\delay.h ****    \note
 153:d:\winavr\avr\include\util\delay.h **** 
 154:d:\winavr\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:d:\winavr\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:d:\winavr\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:d:\winavr\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:d:\winavr\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:d:\winavr\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:d:\winavr\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:d:\winavr\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:d:\winavr\avr\include\util\delay.h ****    not available to the compiler then.
 163:d:\winavr\avr\include\util\delay.h **** 
 164:d:\winavr\avr\include\util\delay.h ****  */
 165:d:\winavr\avr\include\util\delay.h **** void
 166:d:\winavr\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:d:\winavr\avr\include\util\delay.h **** {
 168:d:\winavr\avr\include\util\delay.h **** 	double __tmp ;
 169:d:\winavr\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:d:\winavr\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:d:\winavr\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:d:\winavr\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:d:\winavr\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:d:\winavr\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:d:\winavr\avr\include\util\delay.h **** 
 176:d:\winavr\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:d:\winavr\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:d:\winavr\avr\include\util\delay.h **** 
 179:d:\winavr\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:d:\winavr\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:d:\winavr\avr\include\util\delay.h **** 
 182:d:\winavr\avr\include\util\delay.h **** 	#else
 183:d:\winavr\avr\include\util\delay.h **** 		//round up by default
 184:d:\winavr\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:d:\winavr\avr\include\util\delay.h **** 	#endif
 186:d:\winavr\avr\include\util\delay.h **** 
 187:d:\winavr\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:d:\winavr\avr\include\util\delay.h **** 
 189:d:\winavr\avr\include\util\delay.h **** #else
 190:d:\winavr\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:d:\winavr\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:d:\winavr\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:d:\winavr\avr\include\util\delay.h **** 		__ticks = 1;
 194:d:\winavr\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:d:\winavr\avr\include\util\delay.h **** 	{
 196:d:\winavr\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:d:\winavr\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:d:\winavr\avr\include\util\delay.h **** 		while(__ticks)
 199:d:\winavr\avr\include\util\delay.h **** 		{
 200:d:\winavr\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:d:\winavr\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:d:\winavr\avr\include\util\delay.h **** 			__ticks --;
 203:d:\winavr\avr\include\util\delay.h **** 		}
 204:d:\winavr\avr\include\util\delay.h **** 		return;
 205:d:\winavr\avr\include\util\delay.h **** 	}
 206:d:\winavr\avr\include\util\delay.h **** 	else
 207:d:\winavr\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:d:\winavr\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:d:\winavr\avr\include\util\delay.h **** #endif
 210:d:\winavr\avr\include\util\delay.h **** }
 211:d:\winavr\avr\include\util\delay.h **** 
 212:d:\winavr\avr\include\util\delay.h **** /**
 213:d:\winavr\avr\include\util\delay.h ****    \ingroup util_delay
 214:d:\winavr\avr\include\util\delay.h **** 
 215:d:\winavr\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:d:\winavr\avr\include\util\delay.h **** 
 217:d:\winavr\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:d:\winavr\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:d:\winavr\avr\include\util\delay.h **** 
 220:d:\winavr\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:d:\winavr\avr\include\util\delay.h **** 
 222:d:\winavr\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:d:\winavr\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:d:\winavr\avr\include\util\delay.h ****    will not be informed about this case.
 225:d:\winavr\avr\include\util\delay.h **** 
 226:d:\winavr\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:d:\winavr\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:d:\winavr\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:d:\winavr\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:d:\winavr\avr\include\util\delay.h **** 
 231:d:\winavr\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:d:\winavr\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:d:\winavr\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:d:\winavr\avr\include\util\delay.h ****    microseconds of delay.
 235:d:\winavr\avr\include\util\delay.h **** 
 236:d:\winavr\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:d:\winavr\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:d:\winavr\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:d:\winavr\avr\include\util\delay.h ****    respectively.
 240:d:\winavr\avr\include\util\delay.h **** 
 241:d:\winavr\avr\include\util\delay.h ****    \note
 242:d:\winavr\avr\include\util\delay.h **** 
 243:d:\winavr\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:d:\winavr\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:d:\winavr\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:d:\winavr\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:d:\winavr\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:d:\winavr\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:d:\winavr\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:d:\winavr\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:d:\winavr\avr\include\util\delay.h ****    not available to the compiler then.
 252:d:\winavr\avr\include\util\delay.h **** 
 253:d:\winavr\avr\include\util\delay.h ****  */
 254:d:\winavr\avr\include\util\delay.h **** void
 255:d:\winavr\avr\include\util\delay.h **** _delay_us(double __us)
 256:d:\winavr\avr\include\util\delay.h **** {
 257:d:\winavr\avr\include\util\delay.h **** 	double __tmp ;
 258:d:\winavr\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:d:\winavr\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:d:\winavr\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:d:\winavr\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:d:\winavr\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:d:\winavr\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:d:\winavr\avr\include\util\delay.h **** 
 265:d:\winavr\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:d:\winavr\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:d:\winavr\avr\include\util\delay.h **** 
 268:d:\winavr\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:d:\winavr\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:d:\winavr\avr\include\util\delay.h **** 
 271:d:\winavr\avr\include\util\delay.h **** 	#else
 272:d:\winavr\avr\include\util\delay.h **** 		//round up by default
 273:d:\winavr\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:d:\winavr\avr\include\util\delay.h **** 	#endif
 275:d:\winavr\avr\include\util\delay.h **** 
 276:d:\winavr\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 209               		.loc 2 276 0
 210 00d2 93E9      		ldi r25,lo8(-109)
 211 00d4 9A95      	1:	dec r25
 212 00d6 01F4      		brne 1b
 213 00d8 00C0      		rjmp .
 214               	.LVL9:
 215               	.LBE5:
 216               	.LBE4:
 121:common/ps2kbd.c **** 	_delay_us(120);
 122:common/ps2kbd.c **** 	
 123:common/ps2kbd.c **** 	kbd_bit_n = 1;
 217               		.loc 1 123 0
 218 00da 91E0      		ldi r25,lo8(1)
 219 00dc 9093 0000 		sts kbd_bit_n,r25
 124:common/ps2kbd.c **** 	kbd_status |= KBD_SEND;
 220               		.loc 1 124 0
 221 00e0 2091 0000 		lds r18,kbd_status
 222 00e4 3091 0000 		lds r19,kbd_status+1
 223 00e8 2068      		ori r18,128
 224 00ea 3093 0000 		sts kbd_status+1,r19
 225 00ee 2093 0000 		sts kbd_status,r18
 125:common/ps2kbd.c **** 	kbd_n_bits = 0;
 226               		.loc 1 125 0
 227 00f2 1092 0000 		sts kbd_n_bits,__zero_reg__
 126:common/ps2kbd.c **** 	kbd_buffer = data;
 228               		.loc 1 126 0
 229 00f6 8093 0000 		sts kbd_buffer,r24
 127:common/ps2kbd.c **** 
 128:common/ps2kbd.c **** 	KBD_DATA_DDR   |= (1<<KBD_DATA_BIT);
 230               		.loc 1 128 0
 231 00fa 549A      		sbi 0xa,4
 129:common/ps2kbd.c **** 	KBD_CLOCK_DDR  &= ~(1<<KBD_CLOCK_BIT);
 232               		.loc 1 129 0
 233 00fc 5298      		cbi 0xa,2
 130:common/ps2kbd.c **** 	KBD_CLOCK_PORT |= (1<<KBD_CLOCK_BIT);
 234               		.loc 1 130 0
 235 00fe 5A9A      		sbi 0xb,2
 236 0100 0895      		ret
 237               		.cfi_endproc
 238               	.LFE11:
 240               	.global	ps2_kbd_set_leds
 242               	ps2_kbd_set_leds:
 243               	.LFB12:
 131:common/ps2kbd.c **** }
 132:common/ps2kbd.c **** 
 133:common/ps2kbd.c **** void ps2_kbd_set_leds(uint8_t	kbleds)
 134:common/ps2kbd.c **** {
 244               		.loc 1 134 0
 245               		.cfi_startproc
 246               	.LVL10:
 247 0102 CF93      		push r28
 248               	.LCFI4:
 249               		.cfi_def_cfa_offset 3
 250               		.cfi_offset 28, -2
 251               	/* prologue: function */
 252               	/* frame size = 0 */
 253               	/* stack size = 1 */
 254               	.L__stack_usage = 1
 255 0104 C82F      		mov r28,r24
 135:common/ps2kbd.c **** 	// Send the command to set the LEDS to the keyboard
 136:common/ps2kbd.c **** 	ps2_kbd_send(KBD_CMD_SET_LEDS);
 256               		.loc 1 136 0
 257 0106 8DEE      		ldi r24,lo8(-19)
 258               	.LVL11:
 259 0108 0E94 0000 		call ps2_kbd_send
 260               	.LVL12:
 137:common/ps2kbd.c **** 	ps2_kbd_send(kbleds);
 261               		.loc 1 137 0
 262 010c 8C2F      		mov r24,r28
 263               	/* epilogue start */
 138:common/ps2kbd.c **** }
 264               		.loc 1 138 0
 265 010e CF91      		pop r28
 266               	.LVL13:
 137:common/ps2kbd.c **** 	ps2_kbd_send(kbleds);
 267               		.loc 1 137 0
 268 0110 0C94 0000 		jmp ps2_kbd_send
 269               	.LVL14:
 270               		.cfi_endproc
 271               	.LFE12:
 273               	.global	ps2_kbd_update_leds
 275               	ps2_kbd_update_leds:
 276               	.LFB13:
 139:common/ps2kbd.c **** 
 140:common/ps2kbd.c **** void ps2_kbd_update_leds(void)
 141:common/ps2kbd.c **** {
 277               		.loc 1 141 0
 278               		.cfi_startproc
 279 0114 CF93      		push r28
 280               	.LCFI5:
 281               		.cfi_def_cfa_offset 3
 282               		.cfi_offset 28, -2
 283               	/* prologue: function */
 284               	/* frame size = 0 */
 285               	/* stack size = 1 */
 286               	.L__stack_usage = 1
 287               	.LVL15:
 142:common/ps2kbd.c **** 	uint8_t	val = 0;
 143:common/ps2kbd.c **** 
 144:common/ps2kbd.c **** 	if(kbd_status & KBD_CAPS) val |= 0x04;
 288               		.loc 1 144 0
 289 0116 8091 0000 		lds r24,kbd_status
 290 011a 9091 0000 		lds r25,kbd_status+1
 291 011e 84FF      		sbrs r24,4
 292 0120 00C0      		rjmp .L20
 293 0122 C4E0      		ldi r28,lo8(4)
 294 0124 00C0      		rjmp .L17
 295               	.L20:
 142:common/ps2kbd.c **** 	uint8_t	val = 0;
 296               		.loc 1 142 0
 297 0126 C0E0      		ldi r28,0
 298               	.L17:
 299               	.LVL16:
 145:common/ps2kbd.c **** 	if(kbd_status & KBD_NUMLOCK) val |= 0x02;
 300               		.loc 1 145 0
 301 0128 8091 0000 		lds r24,kbd_status
 302 012c 9091 0000 		lds r25,kbd_status+1
 303 0130 83FD      		sbrc r24,3
 304               		.loc 1 145 0 is_stmt 0 discriminator 1
 305 0132 C260      		ori r28,lo8(2)
 306               	.LVL17:
 307               	.L18:
 146:common/ps2kbd.c **** 	if(kbd_status & KBD_SCROLL) val |= 0x01;
 308               		.loc 1 146 0 is_stmt 1
 309 0134 8091 0000 		lds r24,kbd_status
 310 0138 9091 0000 		lds r25,kbd_status+1
 311 013c 85FD      		sbrc r24,5
 312               		.loc 1 146 0 is_stmt 0 discriminator 1
 313 013e C160      		ori r28,lo8(1)
 314               	.LVL18:
 315               	.L19:
 147:common/ps2kbd.c **** 	
 148:common/ps2kbd.c **** 	ps2_kbd_send(0xed);
 316               		.loc 1 148 0 is_stmt 1
 317 0140 8DEE      		ldi r24,lo8(-19)
 318 0142 0E94 0000 		call ps2_kbd_send
 319               	.LVL19:
 149:common/ps2kbd.c **** 	ps2_kbd_send(val);
 320               		.loc 1 149 0
 321 0146 8C2F      		mov r24,r28
 322               	/* epilogue start */
 150:common/ps2kbd.c **** }
 323               		.loc 1 150 0
 324 0148 CF91      		pop r28
 325               	.LVL20:
 149:common/ps2kbd.c **** 	ps2_kbd_send(val);
 326               		.loc 1 149 0
 327 014a 0C94 0000 		jmp ps2_kbd_send
 328               	.LVL21:
 329               		.cfi_endproc
 330               	.LFE13:
 332               	.global	ps2_poll_leds
 334               	ps2_poll_leds:
 335               	.LFB14:
 151:common/ps2kbd.c **** 
 152:common/ps2kbd.c **** void ps2_poll_leds(void)
 153:common/ps2kbd.c **** {
 336               		.loc 1 153 0
 337               		.cfi_startproc
 338               	/* prologue: function */
 339               	/* frame size = 0 */
 340               	/* stack size = 0 */
 341               	.L__stack_usage = 0
 154:common/ps2kbd.c **** 	if ((PS2_LEDS & PS2_LED_MASK) != (PS2_LEDS_OLD & PS2_LED_MASK))
 342               		.loc 1 154 0
 343 014e 8091 0000 		lds r24,PS2_LEDS
 344 0152 9091 0000 		lds r25,PS2_LEDS_OLD
 345 0156 9827      		eor r25,r24
 346 0158 9770      		andi r25,lo8(7)
 347 015a 01F0      		breq .L27
 155:common/ps2kbd.c **** 	{
 156:common/ps2kbd.c **** 		ps2_kbd_set_leds(PS2_LEDS & PS2_LED_MASK);
 348               		.loc 1 156 0
 349 015c 8770      		andi r24,lo8(7)
 350 015e 0E94 0000 		call ps2_kbd_set_leds
 351               	.LVL22:
 157:common/ps2kbd.c **** 		
 158:common/ps2kbd.c **** 		PS2_LEDS_OLD = PS2_LEDS;
 352               		.loc 1 158 0
 353 0162 8091 0000 		lds r24,PS2_LEDS
 354 0166 8093 0000 		sts PS2_LEDS_OLD,r24
 355               	.L27:
 356 016a 0895      		ret
 357               		.cfi_endproc
 358               	.LFE14:
 360               	.global	kbd_do_lookup
 362               	kbd_do_lookup:
 363               	.LFB15:
 159:common/ps2kbd.c **** 	}
 160:common/ps2kbd.c **** }
 161:common/ps2kbd.c **** 
 162:common/ps2kbd.c **** 
 163:common/ps2kbd.c **** unsigned char kbd_do_lookup(const unsigned char *lut, uint8_t sc)
 164:common/ps2kbd.c **** {
 364               		.loc 1 164 0
 365               		.cfi_startproc
 366               	.LVL23:
 367               	/* prologue: function */
 368               	/* frame size = 0 */
 369               	/* stack size = 0 */
 370               	.L__stack_usage = 0
 371 016c AC01      		movw r20,r24
 372               	.LVL24:
 165:common/ps2kbd.c **** 	uint8_t	i;
 166:common/ps2kbd.c **** 	
 167:common/ps2kbd.c **** 	for(i = 0; pgm_read_byte(&lut[i]); i += 2)
 373               		.loc 1 167 0
 374 016e 90E0      		ldi r25,0
 375               	.LVL25:
 376               	.L33:
 377               	.LBB6:
 378               		.loc 1 167 0 is_stmt 0 discriminator 1
 379 0170 292F      		mov r18,r25
 380 0172 30E0      		ldi r19,0
 381 0174 FA01      		movw r30,r20
 382 0176 E20F      		add r30,r18
 383 0178 F31F      		adc r31,r19
 384               	.LVL26:
 385               	/* #APP */
 386               	 ;  167 "common/ps2kbd.c" 1
 387 017a 8491      		lpm r24, Z
 388               		
 389               	 ;  0 "" 2
 390               	.LVL27:
 391               	/* #NOAPP */
 392               	.LBE6:
 393 017c 8823      		tst r24
 394 017e 01F0      		breq .L37
 395               	.LVL28:
 396               	.LBB7:
 168:common/ps2kbd.c **** 		if(sc == pgm_read_byte(&lut[i]))
 397               		.loc 1 168 0 is_stmt 1
 398               	/* #APP */
 399               	 ;  168 "common/ps2kbd.c" 1
 400 0180 E491      		lpm r30, Z
 401               		
 402               	 ;  0 "" 2
 403               	.LVL29:
 404               	/* #NOAPP */
 405               	.LBE7:
 406 0182 E613      		cpse r30,r22
 407 0184 00C0      		rjmp .L34
 408               	.LVL30:
 409               	.LBB8:
 169:common/ps2kbd.c **** 			return pgm_read_byte(&lut[i + 1]);
 410               		.loc 1 169 0
 411 0186 F901      		movw r30,r18
 412               	.LVL31:
 413 0188 3196      		adiw r30,1
 414 018a E40F      		add r30,r20
 415 018c F51F      		adc r31,r21
 416               	/* #APP */
 417               	 ;  169 "common/ps2kbd.c" 1
 418 018e 8491      		lpm r24, Z
 419               		
 420               	 ;  0 "" 2
 421               	.LVL32:
 422               	/* #NOAPP */
 423               	.LBE8:
 424 0190 0895      		ret
 425               	.LVL33:
 426               	.L34:
 167:common/ps2kbd.c **** 		if(sc == pgm_read_byte(&lut[i]))
 427               		.loc 1 167 0 discriminator 2
 428 0192 9E5F      		subi r25,lo8(-(2))
 429               	.LVL34:
 430 0194 00C0      		rjmp .L33
 431               	.LVL35:
 432               	.L37:
 170:common/ps2kbd.c **** 	return 0;
 171:common/ps2kbd.c **** }
 433               		.loc 1 171 0
 434 0196 0895      		ret
 435               		.cfi_endproc
 436               	.LFE15:
 438               	.global	ps2_kbd_get_status
 440               	ps2_kbd_get_status:
 441               	.LFB16:
 172:common/ps2kbd.c **** 
 173:common/ps2kbd.c **** uint16_t ps2_kbd_get_status()
 174:common/ps2kbd.c **** {
 442               		.loc 1 174 0
 443               		.cfi_startproc
 444               	/* prologue: function */
 445               	/* frame size = 0 */
 446               	/* stack size = 0 */
 447               	.L__stack_usage = 0
 175:common/ps2kbd.c **** 	return kbd_status;
 448               		.loc 1 175 0
 449 0198 8091 0000 		lds r24,kbd_status
 450 019c 9091 0000 		lds r25,kbd_status+1
 176:common/ps2kbd.c **** }
 451               		.loc 1 176 0
 452 01a0 0895      		ret
 453               		.cfi_endproc
 454               	.LFE16:
 456               	.global	__vector_1
 458               	__vector_1:
 459               	.LFB17:
 177:common/ps2kbd.c **** 
 178:common/ps2kbd.c **** 
 179:common/ps2kbd.c **** ISR(PS2_KBD_INT)
 180:common/ps2kbd.c **** {
 460               		.loc 1 180 0
 461               		.cfi_startproc
 462 01a2 1F92      		push r1
 463               	.LCFI6:
 464               		.cfi_def_cfa_offset 3
 465               		.cfi_offset 1, -2
 466 01a4 0F92      		push r0
 467               	.LCFI7:
 468               		.cfi_def_cfa_offset 4
 469               		.cfi_offset 0, -3
 470 01a6 0FB6      		in r0,__SREG__
 471 01a8 0F92      		push r0
 472 01aa 1124      		clr __zero_reg__
 473 01ac 2F93      		push r18
 474               	.LCFI8:
 475               		.cfi_def_cfa_offset 5
 476               		.cfi_offset 18, -4
 477 01ae 3F93      		push r19
 478               	.LCFI9:
 479               		.cfi_def_cfa_offset 6
 480               		.cfi_offset 19, -5
 481 01b0 4F93      		push r20
 482               	.LCFI10:
 483               		.cfi_def_cfa_offset 7
 484               		.cfi_offset 20, -6
 485 01b2 5F93      		push r21
 486               	.LCFI11:
 487               		.cfi_def_cfa_offset 8
 488               		.cfi_offset 21, -7
 489 01b4 6F93      		push r22
 490               	.LCFI12:
 491               		.cfi_def_cfa_offset 9
 492               		.cfi_offset 22, -8
 493 01b6 7F93      		push r23
 494               	.LCFI13:
 495               		.cfi_def_cfa_offset 10
 496               		.cfi_offset 23, -9
 497 01b8 8F93      		push r24
 498               	.LCFI14:
 499               		.cfi_def_cfa_offset 11
 500               		.cfi_offset 24, -10
 501 01ba 9F93      		push r25
 502               	.LCFI15:
 503               		.cfi_def_cfa_offset 12
 504               		.cfi_offset 25, -11
 505 01bc AF93      		push r26
 506               	.LCFI16:
 507               		.cfi_def_cfa_offset 13
 508               		.cfi_offset 26, -12
 509 01be BF93      		push r27
 510               	.LCFI17:
 511               		.cfi_def_cfa_offset 14
 512               		.cfi_offset 27, -13
 513 01c0 EF93      		push r30
 514               	.LCFI18:
 515               		.cfi_def_cfa_offset 15
 516               		.cfi_offset 30, -14
 517 01c2 FF93      		push r31
 518               	.LCFI19:
 519               		.cfi_def_cfa_offset 16
 520               		.cfi_offset 31, -15
 521               	/* prologue: Signal */
 522               	/* frame size = 0 */
 523               	/* stack size = 15 */
 524               	.L__stack_usage = 15
 181:common/ps2kbd.c **** 	uint8_t	bit_in;
 182:common/ps2kbd.c **** 	
 183:common/ps2kbd.c **** 	if(kbd_status & KBD_SEND)
 525               		.loc 1 183 0
 526 01c4 8091 0000 		lds r24,kbd_status
 527 01c8 9091 0000 		lds r25,kbd_status+1
 528 01cc 87FF      		sbrs r24,7
 529 01ce 00C0      		rjmp .L40
 184:common/ps2kbd.c **** 	{
 185:common/ps2kbd.c **** 		// Send data
 186:common/ps2kbd.c **** 		switch (kbd_bit_n)
 530               		.loc 1 186 0
 531 01d0 8091 0000 		lds r24,kbd_bit_n
 532 01d4 8A30      		cpi r24,lo8(10)
 533 01d6 01F0      		breq .L42
 534 01d8 8B30      		cpi r24,lo8(11)
 535 01da 01F0      		breq .L43
 536 01dc 8930      		cpi r24,lo8(9)
 537 01de 01F4      		brne .L64
 187:common/ps2kbd.c **** 		{
 188:common/ps2kbd.c **** 			case 9 :					// Parity bit
 189:common/ps2kbd.c **** 				if(kbd_n_bits & 0x01)
 538               		.loc 1 189 0
 539 01e0 8091 0000 		lds r24,kbd_n_bits
 540 01e4 80FD      		sbrc r24,0
 541 01e6 00C0      		rjmp .L47
 542               	.L42:
 190:common/ps2kbd.c **** 					KBD_DATA_DDR |= KBD_DATA_MASK;
 191:common/ps2kbd.c **** 				else
 192:common/ps2kbd.c **** 					KBD_DATA_DDR &= ~KBD_DATA_MASK;
 193:common/ps2kbd.c **** 			
 194:common/ps2kbd.c **** 				break;
 195:common/ps2kbd.c **** 				
 196:common/ps2kbd.c **** 			case 10 :					// Stop bit
 197:common/ps2kbd.c **** 				KBD_DATA_DDR &= ~KBD_DATA_MASK;
 543               		.loc 1 197 0
 544 01e8 5498      		cbi 0xa,4
 198:common/ps2kbd.c **** 				break;
 545               		.loc 1 198 0
 546 01ea 00C0      		rjmp .L46
 547               	.L43:
 199:common/ps2kbd.c **** 				
 200:common/ps2kbd.c **** 			case 11 : 					// ACK bit, set by device
 201:common/ps2kbd.c **** 				kbd_buffer = 0;
 548               		.loc 1 201 0
 549 01ec 1092 0000 		sts kbd_buffer,__zero_reg__
 202:common/ps2kbd.c **** 				kbd_bit_n = 0;
 550               		.loc 1 202 0
 551 01f0 1092 0000 		sts kbd_bit_n,__zero_reg__
 203:common/ps2kbd.c **** 				kbd_status &= ~KBD_SEND;
 552               		.loc 1 203 0
 553 01f4 8091 0000 		lds r24,kbd_status
 554 01f8 9091 0000 		lds r25,kbd_status+1
 555 01fc 8F77      		andi r24,127
 556 01fe 9093 0000 		sts kbd_status+1,r25
 557 0202 8093 0000 		sts kbd_status,r24
 204:common/ps2kbd.c **** 				break;
 558               		.loc 1 204 0
 559 0206 00C0      		rjmp .L46
 560               	.L64:
 205:common/ps2kbd.c **** 			
 206:common/ps2kbd.c **** 			default : 
 207:common/ps2kbd.c **** 				if(kbd_buffer & (1 << (kbd_bit_n - 1)))
 561               		.loc 1 207 0
 562 0208 8091 0000 		lds r24,kbd_buffer
 563 020c 2091 0000 		lds r18,kbd_bit_n
 564 0210 90E0      		ldi r25,0
 565 0212 2150      		subi r18,lo8(-(-1))
 566 0214 00C0      		rjmp 2f
 567               		1:
 568 0216 9595      		asr r25
 569 0218 8795      		ror r24
 570               		2:
 571 021a 2A95      		dec r18
 572 021c 02F4      		brpl 1b
 573 021e 80FF      		sbrs r24,0
 574 0220 00C0      		rjmp .L47
 208:common/ps2kbd.c **** 				{
 209:common/ps2kbd.c **** 					KBD_DATA_DDR &= ~KBD_DATA_MASK;
 575               		.loc 1 209 0
 576 0222 5498      		cbi 0xa,4
 577 0224 00C0      		rjmp .L66
 578               	.L47:
 210:common/ps2kbd.c **** 					kbd_n_bits++;
 211:common/ps2kbd.c **** 				} 
 212:common/ps2kbd.c **** 				else
 213:common/ps2kbd.c **** 					KBD_DATA_DDR |= KBD_DATA_MASK;
 579               		.loc 1 213 0
 580 0226 549A      		sbi 0xa,4
 581 0228 00C0      		rjmp .L46
 582               	.L40:
 214:common/ps2kbd.c **** 		}
 215:common/ps2kbd.c **** 	} 
 216:common/ps2kbd.c **** 	else
 217:common/ps2kbd.c **** 	{
 218:common/ps2kbd.c **** 		// Receive data
 219:common/ps2kbd.c **** 		
 220:common/ps2kbd.c **** 		//if(kbd_bit_n == 1)
 221:common/ps2kbd.c **** 		//	kbd_status |= KBD_RECEIVE;
 222:common/ps2kbd.c **** 
 223:common/ps2kbd.c **** 		bit_in=(KBD_DATA_PIN & KBD_DATA_MASK) ? 0x01 : 0x00;
 583               		.loc 1 223 0
 584 022a 89B1      		in r24,0x9
 585 022c 8071      		andi r24,lo8(16)
 586               	.LVL36:
 224:common/ps2kbd.c **** 		
 225:common/ps2kbd.c **** 		switch (kbd_bit_n)
 587               		.loc 1 225 0
 588 022e 9091 0000 		lds r25,kbd_bit_n
 589 0232 9A30      		cpi r25,lo8(10)
 590 0234 01F0      		breq .L49
 591 0236 9B30      		cpi r25,lo8(11)
 592 0238 01F0      		breq .L50
 593 023a 9130      		cpi r25,lo8(1)
 594 023c 01F4      		brne .L65
 595 023e 00C0      		rjmp .L46
 596               	.L49:
 223:common/ps2kbd.c **** 		
 597               		.loc 1 223 0
 598 0240 91E0      		ldi r25,lo8(1)
 599 0242 8111      		cpse r24,__zero_reg__
 600 0244 00C0      		rjmp .L51
 601 0246 90E0      		ldi r25,0
 602               	.L51:
 226:common/ps2kbd.c **** 		{
 227:common/ps2kbd.c **** 			case 1 :						// ignore start bit
 228:common/ps2kbd.c **** 				//kbd_status |= KBD_RECEIVE;
 229:common/ps2kbd.c **** 				break;
 230:common/ps2kbd.c **** 					
 231:common/ps2kbd.c **** 			case 10 :						// parity bit
 232:common/ps2kbd.c **** 				kbd_parity=bit_in;
 603               		.loc 1 232 0
 604 0248 9093 0000 		sts kbd_parity,r25
 233:common/ps2kbd.c **** 				break;
 605               		.loc 1 233 0
 606 024c 00C0      		rjmp .L46
 607               	.L50:
 234:common/ps2kbd.c **** 				
 235:common/ps2kbd.c **** 			//case 11 : 						// stop bit
 236:common/ps2kbd.c **** 			//	break;
 237:common/ps2kbd.c **** 				
 238:common/ps2kbd.c **** 			case 11 :
 239:common/ps2kbd.c **** 				kbd_n_bits&=0x01;
 608               		.loc 1 239 0
 609 024e 8091 0000 		lds r24,kbd_n_bits
 610               	.LVL37:
 611 0252 8170      		andi r24,lo8(1)
 612 0254 8093 0000 		sts kbd_n_bits,r24
 240:common/ps2kbd.c **** 				
 241:common/ps2kbd.c **** 				// Only queue code if parity is valid.
 242:common/ps2kbd.c **** 				if (((kbd_parity==1) && (kbd_n_bits==0)) ||
 613               		.loc 1 242 0
 614 0258 8091 0000 		lds r24,kbd_parity
 615 025c 8130      		cpi r24,lo8(1)
 616 025e 01F4      		brne .L52
 617               		.loc 1 242 0 is_stmt 0 discriminator 1
 618 0260 8091 0000 		lds r24,kbd_n_bits
 619 0264 8823      		tst r24
 620 0266 01F0      		breq .L53
 621               	.L52:
 243:common/ps2kbd.c **** 				    ((kbd_parity==0) && (kbd_n_bits==1)))
 622               		.loc 1 243 0 is_stmt 1 discriminator 3
 623 0268 8091 0000 		lds r24,kbd_parity
 242:common/ps2kbd.c **** 				    ((kbd_parity==0) && (kbd_n_bits==1)))
 624               		.loc 1 242 0 discriminator 3
 625 026c 8111      		cpse r24,__zero_reg__
 626 026e 00C0      		rjmp .L54
 627               		.loc 1 243 0
 628 0270 8091 0000 		lds r24,kbd_n_bits
 629 0274 8130      		cpi r24,lo8(1)
 630 0276 01F4      		brne .L54
 631               	.L53:
 244:common/ps2kbd.c **** 					ps2_kbd_queue_scancode(kbd_buffer);
 632               		.loc 1 244 0
 633 0278 8091 0000 		lds r24,kbd_buffer
 634 027c 0E94 0000 		call ps2_kbd_queue_scancode
 635               	.LVL38:
 636               	.L54:
 245:common/ps2kbd.c **** 
 246:common/ps2kbd.c **** 				//logv0("scan=%2X, parity=%d, kbd_n_bits=%d\n",kbd_buffer,kbd_parity,kbd_n_bits); 
 247:common/ps2kbd.c **** 	
 248:common/ps2kbd.c **** 				kbd_buffer = 0;
 637               		.loc 1 248 0
 638 0280 1092 0000 		sts kbd_buffer,__zero_reg__
 249:common/ps2kbd.c **** 				kbd_bit_n = 0;
 639               		.loc 1 249 0
 640 0284 1092 0000 		sts kbd_bit_n,__zero_reg__
 250:common/ps2kbd.c **** 				kbd_parity = 0;
 641               		.loc 1 250 0
 642 0288 1092 0000 		sts kbd_parity,__zero_reg__
 251:common/ps2kbd.c **** 				kbd_n_bits = 0;
 643               		.loc 1 251 0
 644 028c 1092 0000 		sts kbd_n_bits,__zero_reg__
 252:common/ps2kbd.c **** 				//kbd_status &= ~KBD_RECEIVE;
 253:common/ps2kbd.c **** 				break;
 645               		.loc 1 253 0
 646 0290 00C0      		rjmp .L46
 647               	.LVL39:
 648               	.L65:
 254:common/ps2kbd.c **** 				
 255:common/ps2kbd.c **** 			default :						// data bits
 256:common/ps2kbd.c **** 				if(bit_in)
 649               		.loc 1 256 0
 650 0292 8823      		tst r24
 651 0294 01F0      		breq .L46
 257:common/ps2kbd.c **** 				{
 258:common/ps2kbd.c **** 					kbd_buffer |= (1 << (kbd_bit_n - 2));
 652               		.loc 1 258 0
 653 0296 2091 0000 		lds r18,kbd_bit_n
 654 029a 3091 0000 		lds r19,kbd_buffer
 655 029e 2250      		subi r18,lo8(-(-2))
 656 02a0 81E0      		ldi r24,lo8(1)
 657 02a2 90E0      		ldi r25,0
 658               	.LVL40:
 659 02a4 00C0      		rjmp 2f
 660               		1:
 661 02a6 880F      		lsl r24
 662               		2:
 663 02a8 2A95      		dec r18
 664 02aa 02F4      		brpl 1b
 665 02ac 832B      		or r24,r19
 666 02ae 8093 0000 		sts kbd_buffer,r24
 667               	.L66:
 259:common/ps2kbd.c **** 					kbd_n_bits++;
 668               		.loc 1 259 0
 669 02b2 8091 0000 		lds r24,kbd_n_bits
 670 02b6 8F5F      		subi r24,lo8(-(1))
 671 02b8 8093 0000 		sts kbd_n_bits,r24
 672               	.L46:
 260:common/ps2kbd.c **** 				}	
 261:common/ps2kbd.c **** 		}
 262:common/ps2kbd.c **** 		
 263:common/ps2kbd.c **** 	}
 264:common/ps2kbd.c **** 	
 265:common/ps2kbd.c **** 	kbd_bit_n++;
 673               		.loc 1 265 0
 674 02bc 8091 0000 		lds r24,kbd_bit_n
 675 02c0 8F5F      		subi r24,lo8(-(1))
 676 02c2 8093 0000 		sts kbd_bit_n,r24
 677               	/* epilogue start */
 266:common/ps2kbd.c **** 	
 267:common/ps2kbd.c **** //	KBD_SET_INT();
 268:common/ps2kbd.c **** }
 678               		.loc 1 268 0
 679 02c6 FF91      		pop r31
 680 02c8 EF91      		pop r30
 681 02ca BF91      		pop r27
 682 02cc AF91      		pop r26
 683 02ce 9F91      		pop r25
 684 02d0 8F91      		pop r24
 685 02d2 7F91      		pop r23
 686 02d4 6F91      		pop r22
 687 02d6 5F91      		pop r21
 688 02d8 4F91      		pop r20
 689 02da 3F91      		pop r19
 690 02dc 2F91      		pop r18
 691 02de 0F90      		pop r0
 692 02e0 0FBE      		out __SREG__,r0
 693 02e2 0F90      		pop r0
 694 02e4 1F90      		pop r1
 695 02e6 1895      		reti
 696               		.cfi_endproc
 697               	.LFE17:
 699               		.comm	PS2_LEDS_OLD,1,1
 700               		.comm	PS2_LEDS,1,1
 701               	.global	kbd_status
 702               		.section .bss
 705               	kbd_status:
 706 0000 0000      		.zero	2
 707               	.global	kbd_queue_remove
 710               	kbd_queue_remove:
 711 0002 00        		.zero	1
 712               	.global	kbd_queue_insert
 715               	kbd_queue_insert:
 716 0003 00        		.zero	1
 717               		.comm	kbd_parity,1,1
 718               	.global	kbd_queue_idx
 721               	kbd_queue_idx:
 722 0004 00        		.zero	1
 723               		.comm	kbd_queue,129,1
 724               	.global	kbd_buffer
 727               	kbd_buffer:
 728 0005 00        		.zero	1
 729               	.global	kbd_n_bits
 732               	kbd_n_bits:
 733 0006 00        		.zero	1
 734               	.global	kbd_bit_n
 735               		.data
 738               	kbd_bit_n:
 739 0000 01        		.byte	1
 740               		.text
 741               	.Letext0:
 742               		.file 3 "d:\\winavr\\avr\\include\\stdint.h"
DEFINED SYMBOLS
                            *ABS*:00000000 ps2kbd.c
D:\cygwin64\tmp\ccsJEZSd.s:2      *ABS*:0000003e __SP_H__
D:\cygwin64\tmp\ccsJEZSd.s:3      *ABS*:0000003d __SP_L__
D:\cygwin64\tmp\ccsJEZSd.s:4      *ABS*:0000003f __SREG__
D:\cygwin64\tmp\ccsJEZSd.s:5      *ABS*:00000000 __tmp_reg__
D:\cygwin64\tmp\ccsJEZSd.s:6      *ABS*:00000001 __zero_reg__
D:\cygwin64\tmp\ccsJEZSd.s:12     .text:00000000 ps2_kbd_init
                            *COM*:00000081 kbd_queue
D:\cygwin64\tmp\ccsJEZSd.s:715    .bss:00000003 kbd_queue_insert
D:\cygwin64\tmp\ccsJEZSd.s:710    .bss:00000002 kbd_queue_remove
D:\cygwin64\tmp\ccsJEZSd.s:705    .bss:00000000 kbd_status
                            *COM*:00000001 kbd_parity
                            *COM*:00000001 PS2_LEDS
                            *COM*:00000001 PS2_LEDS_OLD
D:\cygwin64\tmp\ccsJEZSd.s:55     .text:00000036 ps2_kbd_queue_scancode
D:\cygwin64\tmp\ccsJEZSd.s:127    .text:00000088 ps2_kbd_get_scancode
D:\cygwin64\tmp\ccsJEZSd.s:176    .text:000000ba ps2_kbd_send
D:\cygwin64\tmp\ccsJEZSd.s:738    .data:00000000 kbd_bit_n
D:\cygwin64\tmp\ccsJEZSd.s:732    .bss:00000006 kbd_n_bits
D:\cygwin64\tmp\ccsJEZSd.s:727    .bss:00000005 kbd_buffer
D:\cygwin64\tmp\ccsJEZSd.s:242    .text:00000102 ps2_kbd_set_leds
D:\cygwin64\tmp\ccsJEZSd.s:275    .text:00000114 ps2_kbd_update_leds
D:\cygwin64\tmp\ccsJEZSd.s:334    .text:0000014e ps2_poll_leds
D:\cygwin64\tmp\ccsJEZSd.s:362    .text:0000016c kbd_do_lookup
D:\cygwin64\tmp\ccsJEZSd.s:440    .text:00000198 ps2_kbd_get_status
D:\cygwin64\tmp\ccsJEZSd.s:458    .text:000001a2 __vector_1
D:\cygwin64\tmp\ccsJEZSd.s:721    .bss:00000004 kbd_queue_idx

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
