   1               		.file	"PS2-to_matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	KeyCallback
  12               	KeyCallback:
  13               	.LFB10:
  14               		.file 1 "common/PS2-to_matrix.c"
   1:common/PS2-to_matrix.c **** /*
   2:common/PS2-to_matrix.c **** 	PS2-to-matrix	: 
   3:common/PS2-to_matrix.c **** 		Keyboard module for translating a PS2 keyboard to a matrix suitable
   4:common/PS2-to_matrix.c **** 		for many retro computers.
   5:common/PS2-to_matrix.c **** 
   6:common/PS2-to_matrix.c **** 	2009-07-28, 2020-12-28, P.Harvey-Smith.
   7:common/PS2-to_matrix.c **** 	
   8:common/PS2-to_matrix.c **** 	Implements the following :
   9:common/PS2-to_matrix.c **** 	
  10:common/PS2-to_matrix.c **** 	1) PS/2 Keyboard interface, driving crosspoint switch connected to
  11:common/PS2-to_matrix.c **** 	   target keyboard interface.
  12:common/PS2-to_matrix.c **** 	
  13:common/PS2-to_matrix.c **** 	2009-09-05 Added the ability to the keyboard module to hadle both the
  14:common/PS2-to_matrix.c **** 	normal and escaped scancodes, this allows us to treat for example
  15:common/PS2-to_matrix.c **** 	left and right ctrl differently and the numeric keypad keys differently
  16:common/PS2-to_matrix.c **** 	from the ins block and seperate cursors.
  17:common/PS2-to_matrix.c **** 	
  18:common/PS2-to_matrix.c **** 	2009-09-06 Added the ability to reset the target from the keyboard by 
  19:common/PS2-to_matrix.c **** 	pressing the break key, this is achieved by attaching PD3 of the AVR to
  20:common/PS2-to_matrix.c **** 	the target reset line. Normally it is configured as an input and allowed 
  21:common/PS2-to_matrix.c **** 	to float. When break is pressed the pin is re-configured as an output and
  22:common/PS2-to_matrix.c **** 	sent low, and then after a delay sent high again.
  23:common/PS2-to_matrix.c **** 	
  24:common/PS2-to_matrix.c **** 	2011-05-25 Ported the new keyboard handling code, this fixes several long 
  25:common/PS2-to_matrix.c **** 	standing hang bugs with the keyboard code, and should hopefully be much more 
  26:common/PS2-to_matrix.c **** 	stable.
  27:common/PS2-to_matrix.c **** 	
  28:common/PS2-to_matrix.c **** */
  29:common/PS2-to_matrix.c **** 
  30:common/PS2-to_matrix.c **** #include <avr/interrupt.h>
  31:common/PS2-to_matrix.c **** #include <inttypes.h>
  32:common/PS2-to_matrix.c **** #include <util/delay.h>
  33:common/PS2-to_matrix.c **** #include "globalio.h"
  34:common/PS2-to_matrix.c **** #include "ps2kbd.h"
  35:common/PS2-to_matrix.c **** #include "ps2scancode.h"
  36:common/PS2-to_matrix.c **** #include "scancode.h"
  37:common/PS2-to_matrix.c **** #include "status.h"
  38:common/PS2-to_matrix.c **** #include "mt8816.h"
  39:common/PS2-to_matrix.c **** #include "matrix_kbd.h"
  40:common/PS2-to_matrix.c **** #include "target_defs.h"
  41:common/PS2-to_matrix.c **** #include "io.h"
  42:common/PS2-to_matrix.c **** 
  43:common/PS2-to_matrix.c **** #define LED_DELAY	150
  44:common/PS2-to_matrix.c **** 
  45:common/PS2-to_matrix.c **** uint8_t KeyCallback(uint8_t	PrefixCode,
  46:common/PS2-to_matrix.c **** 					uint8_t	KeyCode,
  47:common/PS2-to_matrix.c **** 					uint8_t	State);
  48:common/PS2-to_matrix.c **** 					
  49:common/PS2-to_matrix.c **** matrix_t MainMatrix;
  50:common/PS2-to_matrix.c **** 
  51:common/PS2-to_matrix.c **** void init_vars(void)
  52:common/PS2-to_matrix.c **** {
  53:common/PS2-to_matrix.c **** 	logv0("init_vars()\n");
  54:common/PS2-to_matrix.c **** 
  55:common/PS2-to_matrix.c **** 	// We do this here, in the future we could have multiple scancode tables
  56:common/PS2-to_matrix.c **** 	// and switch them around as needed, if we had two machines with similar 
  57:common/PS2-to_matrix.c **** 	// tables e.g. Dragon and CoCo.
  58:common/PS2-to_matrix.c **** 	
  59:common/PS2-to_matrix.c **** 	MainMatrix.output=&mt_output_key;
  60:common/PS2-to_matrix.c **** 	MainMatrix.callback=&KeyCallback;
  61:common/PS2-to_matrix.c **** 	MainMatrix.ScancodeTable=NULL;
  62:common/PS2-to_matrix.c **** 	MainMatrix.ScancodeShiftTable=NULL;
  63:common/PS2-to_matrix.c **** }
  64:common/PS2-to_matrix.c **** 
  65:common/PS2-to_matrix.c **** // Toggle the PS/2 leds so that the user knows the system is ready.
  66:common/PS2-to_matrix.c **** void flag_init(void)
  67:common/PS2-to_matrix.c **** {
  68:common/PS2-to_matrix.c **** 	uint8_t	leds = 0;
  69:common/PS2-to_matrix.c **** 	
  70:common/PS2-to_matrix.c **** 	ps2_kbd_set_leds(leds);	_delay_ms(LED_DELAY);
  71:common/PS2-to_matrix.c **** 	leds|=PS2_LED_SCROLL;
  72:common/PS2-to_matrix.c **** 	ps2_kbd_set_leds(leds);	_delay_ms(LED_DELAY);
  73:common/PS2-to_matrix.c **** 	leds|=PS2_LED_CAPS;
  74:common/PS2-to_matrix.c **** 	ps2_kbd_set_leds(leds);	_delay_ms(LED_DELAY);
  75:common/PS2-to_matrix.c **** 	leds|=PS2_LED_NUMLOCK;
  76:common/PS2-to_matrix.c **** 	ps2_kbd_set_leds(leds);	_delay_ms(LED_DELAY);
  77:common/PS2-to_matrix.c **** 
  78:common/PS2-to_matrix.c **** 	leds&=~PS2_LED_SCROLL;
  79:common/PS2-to_matrix.c **** 	ps2_kbd_set_leds(leds);	_delay_ms(LED_DELAY);
  80:common/PS2-to_matrix.c **** 	leds&=~PS2_LED_CAPS;
  81:common/PS2-to_matrix.c **** 	ps2_kbd_set_leds(leds);	_delay_ms(LED_DELAY);
  82:common/PS2-to_matrix.c **** 	leds&=~PS2_LED_NUMLOCK;
  83:common/PS2-to_matrix.c **** 	ps2_kbd_set_leds(leds);	_delay_ms(LED_DELAY);
  84:common/PS2-to_matrix.c **** }
  85:common/PS2-to_matrix.c **** 
  86:common/PS2-to_matrix.c **** uint8_t KeyCallback(uint8_t	PrefixCode,
  87:common/PS2-to_matrix.c **** 					uint8_t	KeyCode,
  88:common/PS2-to_matrix.c **** 					uint8_t	State)
  89:common/PS2-to_matrix.c **** {
  15               		.loc 1 89 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  90:common/PS2-to_matrix.c **** 	uint8_t result = false;
  91:common/PS2-to_matrix.c **** 	
  92:common/PS2-to_matrix.c **** 	if(State==KEY_DOWN)
  22               		.loc 1 92 0
  23 0000 4130      		cpi r20,lo8(1)
  24 0002 01F4      		brne .L2
  93:common/PS2-to_matrix.c **** 	{
  94:common/PS2-to_matrix.c **** 		switch(KeyCode)
  25               		.loc 1 94 0
  26 0004 6930      		cpi r22,lo8(9)
  27 0006 01F4      		brne .L2
  95:common/PS2-to_matrix.c **** 		{
  96:common/PS2-to_matrix.c **** 			case SCAN_CODE_F10 :
  97:common/PS2-to_matrix.c **** 				logv0("\n");
  28               		.loc 1 97 0
  29 0008 8091 0000 		lds r24,STATUS_VERBOSE
  30               	.LVL1:
  31 000c 8823      		tst r24
  32 000e 01F0      		breq .L2
  33               	.LVL2:
  34               	.LBB20:
  35               	.LBB21:
  36 0010 80E0      		ldi r24,lo8(__c.2197)
  37 0012 90E0      		ldi r25,hi8(__c.2197)
  38 0014 9F93      		push r25
  39               	.LCFI0:
  40               		.cfi_def_cfa_offset 3
  41 0016 8F93      		push r24
  42               	.LCFI1:
  43               		.cfi_def_cfa_offset 4
  44 0018 80E0      		ldi r24,lo8(ser0stream)
  45 001a 90E0      		ldi r25,hi8(ser0stream)
  46 001c 9F93      		push r25
  47               	.LCFI2:
  48               		.cfi_def_cfa_offset 5
  49 001e 8F93      		push r24
  50               	.LCFI3:
  51               		.cfi_def_cfa_offset 6
  52 0020 0E94 0000 		call fprintf_P
  53               	.LVL3:
  54 0024 0F90      		pop __tmp_reg__
  55 0026 0F90      		pop __tmp_reg__
  56 0028 0F90      		pop __tmp_reg__
  57 002a 0F90      		pop __tmp_reg__
  58               	.LCFI4:
  59               		.cfi_def_cfa_offset 2
  60               	.LVL4:
  61               	.L2:
  62               	.LBE21:
  63               	.LBE20:
  98:common/PS2-to_matrix.c **** 				break;
  99:common/PS2-to_matrix.c **** 		}
 100:common/PS2-to_matrix.c **** 	}
 101:common/PS2-to_matrix.c **** 	
 102:common/PS2-to_matrix.c **** 	return result;
 103:common/PS2-to_matrix.c **** }
  64               		.loc 1 103 0
  65 002c 80E0      		ldi r24,0
  66 002e 0895      		ret
  67               		.cfi_endproc
  68               	.LFE10:
  70               	.global	init_vars
  72               	init_vars:
  73               	.LFB8:
  52:common/PS2-to_matrix.c **** 	logv0("init_vars()\n");
  74               		.loc 1 52 0
  75               		.cfi_startproc
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 0 */
  79               	.L__stack_usage = 0
  53:common/PS2-to_matrix.c **** 
  80               		.loc 1 53 0
  81 0030 8091 0000 		lds r24,STATUS_VERBOSE
  82 0034 8823      		tst r24
  83 0036 01F0      		breq .L9
  53:common/PS2-to_matrix.c **** 
  84               		.loc 1 53 0 is_stmt 0 discriminator 1
  85 0038 80E0      		ldi r24,lo8(__c.2184)
  86 003a 90E0      		ldi r25,hi8(__c.2184)
  87 003c 9F93      		push r25
  88               	.LCFI5:
  89               		.cfi_def_cfa_offset 3
  90 003e 8F93      		push r24
  91               	.LCFI6:
  92               		.cfi_def_cfa_offset 4
  93 0040 80E0      		ldi r24,lo8(ser0stream)
  94 0042 90E0      		ldi r25,hi8(ser0stream)
  95 0044 9F93      		push r25
  96               	.LCFI7:
  97               		.cfi_def_cfa_offset 5
  98 0046 8F93      		push r24
  99               	.LCFI8:
 100               		.cfi_def_cfa_offset 6
 101 0048 0E94 0000 		call fprintf_P
 102               	.LVL5:
 103 004c 0F90      		pop __tmp_reg__
 104 004e 0F90      		pop __tmp_reg__
 105 0050 0F90      		pop __tmp_reg__
 106 0052 0F90      		pop __tmp_reg__
 107               	.LCFI9:
 108               		.cfi_def_cfa_offset 2
 109               	.L9:
  59:common/PS2-to_matrix.c **** 	MainMatrix.callback=&KeyCallback;
 110               		.loc 1 59 0 is_stmt 1
 111 0054 80E0      		ldi r24,lo8(gs(mt_output_key))
 112 0056 90E0      		ldi r25,hi8(gs(mt_output_key))
 113 0058 9093 0000 		sts MainMatrix+1,r25
 114 005c 8093 0000 		sts MainMatrix,r24
  60:common/PS2-to_matrix.c **** 	MainMatrix.ScancodeTable=NULL;
 115               		.loc 1 60 0
 116 0060 80E0      		ldi r24,lo8(gs(KeyCallback))
 117 0062 90E0      		ldi r25,hi8(gs(KeyCallback))
 118 0064 9093 0000 		sts MainMatrix+2+1,r25
 119 0068 8093 0000 		sts MainMatrix+2,r24
  61:common/PS2-to_matrix.c **** 	MainMatrix.ScancodeShiftTable=NULL;
 120               		.loc 1 61 0
 121 006c 1092 0000 		sts MainMatrix+4+1,__zero_reg__
 122 0070 1092 0000 		sts MainMatrix+4,__zero_reg__
  62:common/PS2-to_matrix.c **** }
 123               		.loc 1 62 0
 124 0074 1092 0000 		sts MainMatrix+6+1,__zero_reg__
 125 0078 1092 0000 		sts MainMatrix+6,__zero_reg__
 126 007c 0895      		ret
 127               		.cfi_endproc
 128               	.LFE8:
 130               	.global	flag_init
 132               	flag_init:
 133               	.LFB9:
  67:common/PS2-to_matrix.c **** 	uint8_t	leds = 0;
 134               		.loc 1 67 0
 135               		.cfi_startproc
 136               	/* prologue: function */
 137               	/* frame size = 0 */
 138               	/* stack size = 0 */
 139               	.L__stack_usage = 0
 140               	.LVL6:
  70:common/PS2-to_matrix.c **** 	leds|=PS2_LED_SCROLL;
 141               		.loc 1 70 0
 142 007e 80E0      		ldi r24,0
 143 0080 0E94 0000 		call ps2_kbd_set_leds
 144               	.LVL7:
 145               	.LBB22:
 146               	.LBB23:
 147               		.file 2 "d:\\winavr\\avr\\include\\util\\delay.h"
   1:d:\winavr\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:d:\winavr\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:d:\winavr\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:d:\winavr\avr\include\util\delay.h ****    All rights reserved.
   5:d:\winavr\avr\include\util\delay.h **** 
   6:d:\winavr\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:d:\winavr\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:d:\winavr\avr\include\util\delay.h **** 
   9:d:\winavr\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:d:\winavr\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:d:\winavr\avr\include\util\delay.h **** 
  12:d:\winavr\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:d:\winavr\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:d:\winavr\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:d:\winavr\avr\include\util\delay.h ****      distribution.
  16:d:\winavr\avr\include\util\delay.h **** 
  17:d:\winavr\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:d:\winavr\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:d:\winavr\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:d:\winavr\avr\include\util\delay.h **** 
  21:d:\winavr\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:d:\winavr\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:d:\winavr\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:d:\winavr\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:d:\winavr\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:d:\winavr\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:d:\winavr\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:d:\winavr\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:d:\winavr\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:d:\winavr\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:d:\winavr\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:d:\winavr\avr\include\util\delay.h **** 
  33:d:\winavr\avr\include\util\delay.h **** /* $Id$ */
  34:d:\winavr\avr\include\util\delay.h **** 
  35:d:\winavr\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:d:\winavr\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:d:\winavr\avr\include\util\delay.h **** 
  38:d:\winavr\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:d:\winavr\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:d:\winavr\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:d:\winavr\avr\include\util\delay.h **** #  endif
  42:d:\winavr\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:d:\winavr\avr\include\util\delay.h **** 
  44:d:\winavr\avr\include\util\delay.h **** #include <inttypes.h>
  45:d:\winavr\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:d:\winavr\avr\include\util\delay.h **** #include <math.h>
  47:d:\winavr\avr\include\util\delay.h **** 
  48:d:\winavr\avr\include\util\delay.h **** /** \file */
  49:d:\winavr\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:d:\winavr\avr\include\util\delay.h ****     \code
  51:d:\winavr\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:d:\winavr\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:d:\winavr\avr\include\util\delay.h ****     #include <util/delay.h>
  54:d:\winavr\avr\include\util\delay.h ****     \endcode
  55:d:\winavr\avr\include\util\delay.h **** 
  56:d:\winavr\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:d:\winavr\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:d:\winavr\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:d:\winavr\avr\include\util\delay.h ****     used.
  60:d:\winavr\avr\include\util\delay.h **** 
  61:d:\winavr\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:d:\winavr\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:d:\winavr\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:d:\winavr\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:d:\winavr\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:d:\winavr\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:d:\winavr\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:d:\winavr\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:d:\winavr\avr\include\util\delay.h **** 
  70:d:\winavr\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:d:\winavr\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:d:\winavr\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:d:\winavr\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:d:\winavr\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:d:\winavr\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:d:\winavr\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:d:\winavr\avr\include\util\delay.h ****     routines linked into the application.
  78:d:\winavr\avr\include\util\delay.h **** 
  79:d:\winavr\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:d:\winavr\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:d:\winavr\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:d:\winavr\avr\include\util\delay.h **** 
  83:d:\winavr\avr\include\util\delay.h **** */
  84:d:\winavr\avr\include\util\delay.h **** 
  85:d:\winavr\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:d:\winavr\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:d:\winavr\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:d:\winavr\avr\include\util\delay.h **** #endif
  89:d:\winavr\avr\include\util\delay.h **** 
  90:d:\winavr\avr\include\util\delay.h **** #ifndef F_CPU
  91:d:\winavr\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:d:\winavr\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:d:\winavr\avr\include\util\delay.h **** /** \ingroup util_delay
  94:d:\winavr\avr\include\util\delay.h ****     \def F_CPU
  95:d:\winavr\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:d:\winavr\avr\include\util\delay.h **** 
  97:d:\winavr\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:d:\winavr\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:d:\winavr\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:d:\winavr\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:d:\winavr\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:d:\winavr\avr\include\util\delay.h **** 
 103:d:\winavr\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:d:\winavr\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:d:\winavr\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:d:\winavr\avr\include\util\delay.h ****     integer value.
 107:d:\winavr\avr\include\util\delay.h ****  */
 108:d:\winavr\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:d:\winavr\avr\include\util\delay.h **** #endif
 110:d:\winavr\avr\include\util\delay.h **** 
 111:d:\winavr\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:d:\winavr\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:d:\winavr\avr\include\util\delay.h **** #endif
 114:d:\winavr\avr\include\util\delay.h **** 
 115:d:\winavr\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:d:\winavr\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:d:\winavr\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:d:\winavr\avr\include\util\delay.h **** #  include <math.h>
 119:d:\winavr\avr\include\util\delay.h **** #endif
 120:d:\winavr\avr\include\util\delay.h **** 
 121:d:\winavr\avr\include\util\delay.h **** /**
 122:d:\winavr\avr\include\util\delay.h ****    \ingroup util_delay
 123:d:\winavr\avr\include\util\delay.h **** 
 124:d:\winavr\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:d:\winavr\avr\include\util\delay.h **** 
 126:d:\winavr\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:d:\winavr\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:d:\winavr\avr\include\util\delay.h **** 
 129:d:\winavr\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:d:\winavr\avr\include\util\delay.h **** 
 131:d:\winavr\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:d:\winavr\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:d:\winavr\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:d:\winavr\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:d:\winavr\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:d:\winavr\avr\include\util\delay.h **** 
 137:d:\winavr\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:d:\winavr\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:d:\winavr\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:d:\winavr\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:d:\winavr\avr\include\util\delay.h **** 
 142:d:\winavr\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:d:\winavr\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:d:\winavr\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:d:\winavr\avr\include\util\delay.h ****    microseconds of delay.
 146:d:\winavr\avr\include\util\delay.h **** 
 147:d:\winavr\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:d:\winavr\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:d:\winavr\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:d:\winavr\avr\include\util\delay.h ****    respectively.
 151:d:\winavr\avr\include\util\delay.h **** 
 152:d:\winavr\avr\include\util\delay.h ****    \note
 153:d:\winavr\avr\include\util\delay.h **** 
 154:d:\winavr\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:d:\winavr\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:d:\winavr\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:d:\winavr\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:d:\winavr\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:d:\winavr\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:d:\winavr\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:d:\winavr\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:d:\winavr\avr\include\util\delay.h ****    not available to the compiler then.
 163:d:\winavr\avr\include\util\delay.h **** 
 164:d:\winavr\avr\include\util\delay.h ****  */
 165:d:\winavr\avr\include\util\delay.h **** void
 166:d:\winavr\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:d:\winavr\avr\include\util\delay.h **** {
 168:d:\winavr\avr\include\util\delay.h **** 	double __tmp ;
 169:d:\winavr\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:d:\winavr\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:d:\winavr\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:d:\winavr\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:d:\winavr\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:d:\winavr\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:d:\winavr\avr\include\util\delay.h **** 
 176:d:\winavr\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:d:\winavr\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:d:\winavr\avr\include\util\delay.h **** 
 179:d:\winavr\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:d:\winavr\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:d:\winavr\avr\include\util\delay.h **** 
 182:d:\winavr\avr\include\util\delay.h **** 	#else
 183:d:\winavr\avr\include\util\delay.h **** 		//round up by default
 184:d:\winavr\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:d:\winavr\avr\include\util\delay.h **** 	#endif
 186:d:\winavr\avr\include\util\delay.h **** 
 187:d:\winavr\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 148               		.loc 2 187 0
 149 0084 2FEF      		ldi r18,lo8(110591)
 150 0086 8FEA      		ldi r24,hi8(110591)
 151 0088 91E0      		ldi r25,hlo8(110591)
 152 008a 2150      	1:	subi r18,1
 153 008c 8040      		sbci r24,0
 154 008e 9040      		sbci r25,0
 155 0090 01F4      		brne 1b
 156 0092 00C0      		rjmp .
 157 0094 0000      		nop
 158               	.LVL8:
 159               	.LBE23:
 160               	.LBE22:
  72:common/PS2-to_matrix.c **** 	leds|=PS2_LED_CAPS;
 161               		.loc 1 72 0
 162 0096 81E0      		ldi r24,lo8(1)
 163 0098 0E94 0000 		call ps2_kbd_set_leds
 164               	.LVL9:
 165               	.LBB24:
 166               	.LBB25:
 167               		.loc 2 187 0
 168 009c 2FEF      		ldi r18,lo8(110591)
 169 009e 8FEA      		ldi r24,hi8(110591)
 170 00a0 91E0      		ldi r25,hlo8(110591)
 171 00a2 2150      	1:	subi r18,1
 172 00a4 8040      		sbci r24,0
 173 00a6 9040      		sbci r25,0
 174 00a8 01F4      		brne 1b
 175 00aa 00C0      		rjmp .
 176 00ac 0000      		nop
 177               	.LVL10:
 178               	.LBE25:
 179               	.LBE24:
  74:common/PS2-to_matrix.c **** 	leds|=PS2_LED_NUMLOCK;
 180               		.loc 1 74 0
 181 00ae 85E0      		ldi r24,lo8(5)
 182 00b0 0E94 0000 		call ps2_kbd_set_leds
 183               	.LVL11:
 184               	.LBB26:
 185               	.LBB27:
 186               		.loc 2 187 0
 187 00b4 2FEF      		ldi r18,lo8(110591)
 188 00b6 8FEA      		ldi r24,hi8(110591)
 189 00b8 91E0      		ldi r25,hlo8(110591)
 190 00ba 2150      	1:	subi r18,1
 191 00bc 8040      		sbci r24,0
 192 00be 9040      		sbci r25,0
 193 00c0 01F4      		brne 1b
 194 00c2 00C0      		rjmp .
 195 00c4 0000      		nop
 196               	.LVL12:
 197               	.LBE27:
 198               	.LBE26:
  76:common/PS2-to_matrix.c **** 
 199               		.loc 1 76 0
 200 00c6 87E0      		ldi r24,lo8(7)
 201 00c8 0E94 0000 		call ps2_kbd_set_leds
 202               	.LVL13:
 203               	.LBB28:
 204               	.LBB29:
 205               		.loc 2 187 0
 206 00cc 2FEF      		ldi r18,lo8(110591)
 207 00ce 8FEA      		ldi r24,hi8(110591)
 208 00d0 91E0      		ldi r25,hlo8(110591)
 209 00d2 2150      	1:	subi r18,1
 210 00d4 8040      		sbci r24,0
 211 00d6 9040      		sbci r25,0
 212 00d8 01F4      		brne 1b
 213 00da 00C0      		rjmp .
 214 00dc 0000      		nop
 215               	.LVL14:
 216               	.LBE29:
 217               	.LBE28:
  79:common/PS2-to_matrix.c **** 	leds&=~PS2_LED_CAPS;
 218               		.loc 1 79 0
 219 00de 86E0      		ldi r24,lo8(6)
 220 00e0 0E94 0000 		call ps2_kbd_set_leds
 221               	.LVL15:
 222               	.LBB30:
 223               	.LBB31:
 224               		.loc 2 187 0
 225 00e4 2FEF      		ldi r18,lo8(110591)
 226 00e6 8FEA      		ldi r24,hi8(110591)
 227 00e8 91E0      		ldi r25,hlo8(110591)
 228 00ea 2150      	1:	subi r18,1
 229 00ec 8040      		sbci r24,0
 230 00ee 9040      		sbci r25,0
 231 00f0 01F4      		brne 1b
 232 00f2 00C0      		rjmp .
 233 00f4 0000      		nop
 234               	.LVL16:
 235               	.LBE31:
 236               	.LBE30:
  81:common/PS2-to_matrix.c **** 	leds&=~PS2_LED_NUMLOCK;
 237               		.loc 1 81 0
 238 00f6 82E0      		ldi r24,lo8(2)
 239 00f8 0E94 0000 		call ps2_kbd_set_leds
 240               	.LVL17:
 241               	.LBB32:
 242               	.LBB33:
 243               		.loc 2 187 0
 244 00fc 2FEF      		ldi r18,lo8(110591)
 245 00fe 8FEA      		ldi r24,hi8(110591)
 246 0100 91E0      		ldi r25,hlo8(110591)
 247 0102 2150      	1:	subi r18,1
 248 0104 8040      		sbci r24,0
 249 0106 9040      		sbci r25,0
 250 0108 01F4      		brne 1b
 251 010a 00C0      		rjmp .
 252 010c 0000      		nop
 253               	.LVL18:
 254               	.LBE33:
 255               	.LBE32:
  83:common/PS2-to_matrix.c **** }
 256               		.loc 1 83 0
 257 010e 80E0      		ldi r24,0
 258 0110 0E94 0000 		call ps2_kbd_set_leds
 259               	.LVL19:
 260               	.LBB34:
 261               	.LBB35:
 262               		.loc 2 187 0
 263 0114 2FEF      		ldi r18,lo8(110591)
 264 0116 8FEA      		ldi r24,hi8(110591)
 265 0118 91E0      		ldi r25,hlo8(110591)
 266 011a 2150      	1:	subi r18,1
 267 011c 8040      		sbci r24,0
 268 011e 9040      		sbci r25,0
 269 0120 01F4      		brne 1b
 270 0122 00C0      		rjmp .
 271 0124 0000      		nop
 272               	.LVL20:
 273 0126 0895      		ret
 274               	.LBE35:
 275               	.LBE34:
 276               		.cfi_endproc
 277               	.LFE9:
 279               		.section	.text.startup,"ax",@progbits
 280               	.global	main
 282               	main:
 283               	.LFB11:
 104:common/PS2-to_matrix.c **** 
 105:common/PS2-to_matrix.c **** int main(void)
 106:common/PS2-to_matrix.c **** {
 284               		.loc 1 106 0
 285               		.cfi_startproc
 286               	/* prologue: function */
 287               	/* frame size = 0 */
 288               	/* stack size = 0 */
 289               	.L__stack_usage = 0
 107:common/PS2-to_matrix.c **** 	GlobalIOInit();
 290               		.loc 1 107 0
 291 0000 0E94 0000 		call GlobalIOInit
 292               	.LVL21:
 108:common/PS2-to_matrix.c **** 	
 109:common/PS2-to_matrix.c **** 	Serial_Init(115200,115200,DIPIsSet(DIPS3));
 293               		.loc 1 109 0
 294 0004 03B1      		in r16,0x3
 295 0006 03FB      		bst r16,3
 296 0008 0027      		clr r16
 297 000a 00F9      		bld r16,0
 298 000c 81E0      		ldi r24,lo8(1)
 299 000e 0827      		eor r16,r24
 300 0010 20E0      		ldi r18,0
 301 0012 32EC      		ldi r19,lo8(-62)
 302 0014 41E0      		ldi r20,lo8(1)
 303 0016 50E0      		ldi r21,0
 304 0018 60E0      		ldi r22,0
 305 001a 72EC      		ldi r23,lo8(-62)
 306 001c 81E0      		ldi r24,lo8(1)
 307 001e 90E0      		ldi r25,0
 308 0020 0E94 0000 		call Serial_Init
 309               	.LVL22:
 110:common/PS2-to_matrix.c **** 	logv0(TARGET_NAME" PS/2 Keyboard interface V1.0\n");
 310               		.loc 1 110 0
 311 0024 8091 0000 		lds r24,STATUS_VERBOSE
 312 0028 8823      		tst r24
 313 002a 01F0      		breq .L15
 314               		.loc 1 110 0 is_stmt 0 discriminator 1
 315 002c 80E0      		ldi r24,lo8(__c.2203)
 316 002e 90E0      		ldi r25,hi8(__c.2203)
 317 0030 9F93      		push r25
 318               	.LCFI10:
 319               		.cfi_def_cfa_offset 3
 320 0032 8F93      		push r24
 321               	.LCFI11:
 322               		.cfi_def_cfa_offset 4
 323 0034 80E0      		ldi r24,lo8(ser0stream)
 324 0036 90E0      		ldi r25,hi8(ser0stream)
 325 0038 9F93      		push r25
 326               	.LCFI12:
 327               		.cfi_def_cfa_offset 5
 328 003a 8F93      		push r24
 329               	.LCFI13:
 330               		.cfi_def_cfa_offset 6
 331 003c 0E94 0000 		call fprintf_P
 332               	.LVL23:
 333 0040 0F90      		pop __tmp_reg__
 334 0042 0F90      		pop __tmp_reg__
 335 0044 0F90      		pop __tmp_reg__
 336 0046 0F90      		pop __tmp_reg__
 337               	.LCFI14:
 338               		.cfi_def_cfa_offset 2
 339               	.L15:
 111:common/PS2-to_matrix.c **** 	logv0("2021-01-06 Ramoth Software.\n");
 340               		.loc 1 111 0 is_stmt 1
 341 0048 8091 0000 		lds r24,STATUS_VERBOSE
 342 004c 8823      		tst r24
 343 004e 01F0      		breq .L16
 344               		.loc 1 111 0 is_stmt 0 discriminator 1
 345 0050 80E0      		ldi r24,lo8(__c.2205)
 346 0052 90E0      		ldi r25,hi8(__c.2205)
 347 0054 9F93      		push r25
 348               	.LCFI15:
 349               		.cfi_def_cfa_offset 3
 350 0056 8F93      		push r24
 351               	.LCFI16:
 352               		.cfi_def_cfa_offset 4
 353 0058 80E0      		ldi r24,lo8(ser0stream)
 354 005a 90E0      		ldi r25,hi8(ser0stream)
 355 005c 9F93      		push r25
 356               	.LCFI17:
 357               		.cfi_def_cfa_offset 5
 358 005e 8F93      		push r24
 359               	.LCFI18:
 360               		.cfi_def_cfa_offset 6
 361 0060 0E94 0000 		call fprintf_P
 362               	.LVL24:
 363 0064 0F90      		pop __tmp_reg__
 364 0066 0F90      		pop __tmp_reg__
 365 0068 0F90      		pop __tmp_reg__
 366 006a 0F90      		pop __tmp_reg__
 367               	.LCFI19:
 368               		.cfi_def_cfa_offset 2
 369               	.L16:
 112:common/PS2-to_matrix.c **** 	
 113:common/PS2-to_matrix.c **** 	init_vars();
 370               		.loc 1 113 0 is_stmt 1
 371 006c 0E94 0000 		call init_vars
 372               	.LVL25:
 114:common/PS2-to_matrix.c **** 	
 115:common/PS2-to_matrix.c **** 	logv0("PS/2 keyboard init\n");
 373               		.loc 1 115 0
 374 0070 8091 0000 		lds r24,STATUS_VERBOSE
 375 0074 8823      		tst r24
 376 0076 01F0      		breq .L17
 377               		.loc 1 115 0 is_stmt 0 discriminator 1
 378 0078 80E0      		ldi r24,lo8(__c.2207)
 379 007a 90E0      		ldi r25,hi8(__c.2207)
 380 007c 9F93      		push r25
 381               	.LCFI20:
 382               		.cfi_def_cfa_offset 3
 383 007e 8F93      		push r24
 384               	.LCFI21:
 385               		.cfi_def_cfa_offset 4
 386 0080 80E0      		ldi r24,lo8(ser0stream)
 387 0082 90E0      		ldi r25,hi8(ser0stream)
 388 0084 9F93      		push r25
 389               	.LCFI22:
 390               		.cfi_def_cfa_offset 5
 391 0086 8F93      		push r24
 392               	.LCFI23:
 393               		.cfi_def_cfa_offset 6
 394 0088 0E94 0000 		call fprintf_P
 395               	.LVL26:
 396 008c 0F90      		pop __tmp_reg__
 397 008e 0F90      		pop __tmp_reg__
 398 0090 0F90      		pop __tmp_reg__
 399 0092 0F90      		pop __tmp_reg__
 400               	.LCFI24:
 401               		.cfi_def_cfa_offset 2
 402               	.L17:
 116:common/PS2-to_matrix.c **** 	ps2_kbd_init();
 403               		.loc 1 116 0 is_stmt 1
 404 0094 0E94 0000 		call ps2_kbd_init
 405               	.LVL27:
 117:common/PS2-to_matrix.c **** 
 118:common/PS2-to_matrix.c **** 	mt_init();
 406               		.loc 1 118 0
 407 0098 0E94 0000 		call mt_init
 408               	.LVL28:
 119:common/PS2-to_matrix.c **** 	ScancodeInit(&MainMatrix);
 409               		.loc 1 119 0
 410 009c 80E0      		ldi r24,lo8(MainMatrix)
 411 009e 90E0      		ldi r25,hi8(MainMatrix)
 412 00a0 0E94 0000 		call ScancodeInit
 413               	.LVL29:
 120:common/PS2-to_matrix.c **** 	
 121:common/PS2-to_matrix.c **** 	matrix_init(&MainMatrix);
 414               		.loc 1 121 0
 415 00a4 80E0      		ldi r24,lo8(MainMatrix)
 416 00a6 90E0      		ldi r25,hi8(MainMatrix)
 417 00a8 0E94 0000 		call matrix_init
 418               	.LVL30:
 122:common/PS2-to_matrix.c **** 	
 123:common/PS2-to_matrix.c **** 	logv0("I/O Init\n");
 419               		.loc 1 123 0
 420 00ac 8091 0000 		lds r24,STATUS_VERBOSE
 421 00b0 8823      		tst r24
 422 00b2 01F0      		breq .L18
 423               		.loc 1 123 0 is_stmt 0 discriminator 1
 424 00b4 80E0      		ldi r24,lo8(__c.2209)
 425 00b6 90E0      		ldi r25,hi8(__c.2209)
 426 00b8 9F93      		push r25
 427               	.LCFI25:
 428               		.cfi_def_cfa_offset 3
 429 00ba 8F93      		push r24
 430               	.LCFI26:
 431               		.cfi_def_cfa_offset 4
 432 00bc 80E0      		ldi r24,lo8(ser0stream)
 433 00be 90E0      		ldi r25,hi8(ser0stream)
 434 00c0 9F93      		push r25
 435               	.LCFI27:
 436               		.cfi_def_cfa_offset 5
 437 00c2 8F93      		push r24
 438               	.LCFI28:
 439               		.cfi_def_cfa_offset 6
 440 00c4 0E94 0000 		call fprintf_P
 441               	.LVL31:
 442 00c8 0F90      		pop __tmp_reg__
 443 00ca 0F90      		pop __tmp_reg__
 444 00cc 0F90      		pop __tmp_reg__
 445 00ce 0F90      		pop __tmp_reg__
 446               	.LCFI29:
 447               		.cfi_def_cfa_offset 2
 448               	.L18:
 124:common/PS2-to_matrix.c **** 	InitIO();
 449               		.loc 1 124 0 is_stmt 1
 450 00d0 0E94 0000 		call InitIO
 451               	.LVL32:
 125:common/PS2-to_matrix.c **** 	
 126:common/PS2-to_matrix.c **** 	logv0("init done!\n");
 452               		.loc 1 126 0
 453 00d4 8091 0000 		lds r24,STATUS_VERBOSE
 454 00d8 8823      		tst r24
 455 00da 01F0      		breq .L19
 456               		.loc 1 126 0 is_stmt 0 discriminator 1
 457 00dc 80E0      		ldi r24,lo8(__c.2211)
 458 00de 90E0      		ldi r25,hi8(__c.2211)
 459 00e0 9F93      		push r25
 460               	.LCFI30:
 461               		.cfi_def_cfa_offset 3
 462 00e2 8F93      		push r24
 463               	.LCFI31:
 464               		.cfi_def_cfa_offset 4
 465 00e4 80E0      		ldi r24,lo8(ser0stream)
 466 00e6 90E0      		ldi r25,hi8(ser0stream)
 467 00e8 9F93      		push r25
 468               	.LCFI32:
 469               		.cfi_def_cfa_offset 5
 470 00ea 8F93      		push r24
 471               	.LCFI33:
 472               		.cfi_def_cfa_offset 6
 473 00ec 0E94 0000 		call fprintf_P
 474               	.LVL33:
 475 00f0 0F90      		pop __tmp_reg__
 476 00f2 0F90      		pop __tmp_reg__
 477 00f4 0F90      		pop __tmp_reg__
 478 00f6 0F90      		pop __tmp_reg__
 479               	.LCFI34:
 480               		.cfi_def_cfa_offset 2
 481               	.L19:
 127:common/PS2-to_matrix.c **** 	sei();
 482               		.loc 1 127 0 is_stmt 1
 483               	/* #APP */
 484               	 ;  127 "common/PS2-to_matrix.c" 1
 485 00f8 7894      		sei
 486               	 ;  0 "" 2
 128:common/PS2-to_matrix.c **** 
 129:common/PS2-to_matrix.c **** 	flag_init();
 487               		.loc 1 129 0
 488               	/* #NOAPP */
 489 00fa 0E94 0000 		call flag_init
 490               	.LVL34:
 491               	.L20:
 130:common/PS2-to_matrix.c **** 
 131:common/PS2-to_matrix.c **** 	while(1)
 132:common/PS2-to_matrix.c **** 	{
 133:common/PS2-to_matrix.c **** 		matrix_check_output();	// Check if PS/2 scancodes waiting to be output to matrix.
 492               		.loc 1 133 0 discriminator 1
 493 00fe 0E94 0000 		call matrix_check_output
 494               	.LVL35:
 134:common/PS2-to_matrix.c **** 		MainLoopPoll();			// Poll the I/O driver for work.
 495               		.loc 1 134 0 discriminator 1
 496 0102 0E94 0000 		call MainLoopPoll
 497               	.LVL36:
 135:common/PS2-to_matrix.c **** 		ps2_poll_leds();		// update keyboard LEDS if needed
 498               		.loc 1 135 0 discriminator 1
 499 0106 0E94 0000 		call ps2_poll_leds
 500               	.LVL37:
 501 010a 00C0      		rjmp .L20
 502               		.cfi_endproc
 503               	.LFE11:
 505               		.section	.progmem.data,"a",@progbits
 508               	__c.2211:
 509 0000 696E 6974 		.string	"init done!\n"
 509      2064 6F6E 
 509      6521 0A00 
 512               	__c.2209:
 513 000c 492F 4F20 		.string	"I/O Init\n"
 513      496E 6974 
 513      0A00 
 516               	__c.2207:
 517 0016 5053 2F32 		.string	"PS/2 keyboard init\n"
 517      206B 6579 
 517      626F 6172 
 517      6420 696E 
 517      6974 0A00 
 520               	__c.2205:
 521 002a 3230 3231 		.string	"2021-01-06 Ramoth Software.\n"
 521      2D30 312D 
 521      3036 2052 
 521      616D 6F74 
 521      6820 536F 
 524               	__c.2203:
 525 0047 4472 6167 		.string	"Dragon 128 / Project Beta  PS/2 Keyboard interface V1.0\n"
 525      6F6E 2031 
 525      3238 202F 
 525      2050 726F 
 525      6A65 6374 
 528               	__c.2197:
 529 0080 0A00      		.string	"\n"
 532               	__c.2184:
 533 0082 696E 6974 		.string	"init_vars()\n"
 533      5F76 6172 
 533      7328 290A 
 533      00
 534               		.comm	MainMatrix,10,1
 535               		.text
 536               	.Letext0:
 537               		.file 3 "d:\\winavr\\avr\\include\\stdint.h"
 538               		.file 4 "./common/matrix_kbd.h"
 539               		.file 5 "d:\\winavr\\avr\\include\\stdio.h"
 540               		.file 6 "common/status.h"
 541               		.file 7 "common/ps2kbd.h"
 542               		.file 8 "common/globalio.h"
 543               		.file 9 "common/mt8816.h"
 544               		.file 10 "./dragon_beta/scancode.h"
 545               		.file 11 "./dragon_beta/io.h"
DEFINED SYMBOLS
                            *ABS*:00000000 PS2-to_matrix.c
D:\cygwin64\tmp\ccsZjcsI.s:2      *ABS*:0000003e __SP_H__
D:\cygwin64\tmp\ccsZjcsI.s:3      *ABS*:0000003d __SP_L__
D:\cygwin64\tmp\ccsZjcsI.s:4      *ABS*:0000003f __SREG__
D:\cygwin64\tmp\ccsZjcsI.s:5      *ABS*:00000000 __tmp_reg__
D:\cygwin64\tmp\ccsZjcsI.s:6      *ABS*:00000001 __zero_reg__
D:\cygwin64\tmp\ccsZjcsI.s:12     .text:00000000 KeyCallback
D:\cygwin64\tmp\ccsZjcsI.s:528    .progmem.data:00000080 __c.2197
D:\cygwin64\tmp\ccsZjcsI.s:72     .text:00000030 init_vars
D:\cygwin64\tmp\ccsZjcsI.s:532    .progmem.data:00000082 __c.2184
                            *COM*:0000000a MainMatrix
D:\cygwin64\tmp\ccsZjcsI.s:132    .text:0000007e flag_init
D:\cygwin64\tmp\ccsZjcsI.s:282    .text.startup:00000000 main
D:\cygwin64\tmp\ccsZjcsI.s:524    .progmem.data:00000047 __c.2203
D:\cygwin64\tmp\ccsZjcsI.s:520    .progmem.data:0000002a __c.2205
D:\cygwin64\tmp\ccsZjcsI.s:516    .progmem.data:00000016 __c.2207
D:\cygwin64\tmp\ccsZjcsI.s:512    .progmem.data:0000000c __c.2209
D:\cygwin64\tmp\ccsZjcsI.s:508    .progmem.data:00000000 __c.2211

UNDEFINED SYMBOLS
STATUS_VERBOSE
ser0stream
fprintf_P
mt_output_key
ps2_kbd_set_leds
GlobalIOInit
Serial_Init
ps2_kbd_init
mt_init
ScancodeInit
matrix_init
InitIO
matrix_check_output
MainLoopPoll
ps2_poll_leds
__do_clear_bss
